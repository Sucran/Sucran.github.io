<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[超燃老哥]]></title>
  <link href="chaoranlaoge.top/atom.xml" rel="self"/>
  <link href="chaoranlaoge.top/"/>
  <updated>2022-03-17T00:39:17+08:00</updated>
  <id>chaoranlaoge.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Alluxio数据编排原理与解析]]></title>
    <link href="chaoranlaoge.top/16474467310881.html"/>
    <updated>2022-03-17T00:05:31+08:00</updated>
    <id>chaoranlaoge.top/16474467310881.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alluxio 安装与实践]]></title>
    <link href="chaoranlaoge.top/16467274330567.html"/>
    <updated>2022-03-08T16:17:13+08:00</updated>
    <id>chaoranlaoge.top/16467274330567.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%8D%95%E6%9C%BA%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>单机环境</h2>
<p>开通阿里云ECS服务器，需要选择基础镜像包含Java8</p>
<ol>
<li>下载Alluxio安装包</li>
</ol>
<p><code>wget https://downloads.alluxio.io/downloads/files/2.7.3/alluxio-2.7.3-bin.tar.gz</code></p>
<ol start="2">
<li>解压安装包</li>
</ol>
<p><code>gunzip alluxio-2.7.3-bin.tar.gz &amp;&amp; tar -xvf alluxio-2.7.3-bin.tar</code></p>
<ol start="3">
<li>设置配置文件并检查本地安装环境</li>
</ol>
<p><code>cd alluxio-2.7.3</code></p>
<p><code>cp conf/alluxio-site.properties.template conf/alluxio-site.properties</code></p>
<p>在conf/alluxio-site.properties文件中将 alluxio.master.hostname设置为 localhost。</p>
<p>执行命令</p>
<p><code>./bin/alluxio validateEnv local</code>验证本地环境</p>
<p>最后会打印出检查结果</p>
<ol start="4">
<li>执行Alluxio的格式化操作</li>
</ol>
<p><code>./bin/alluxio format</code></p>
<p>日志会打到 <code>alluxio-2.7.3/logs/task.log</code></p>
<p>可能会遇到找不到java命令的报错：<br />
<code>Error: Cannot find 'java' on path or under $JAVA_HOME/bin/. Please set JAVA_HOME in alluxio-env.sh or user bash profile.</code></p>
<p>需要将本地的java程序做一个软链接，比如：<br />
<code>ln -s /usr/java/jdk1.8.0_301/bin/java /usr/bin/java</code></p>
<p>还可能会遇到报错：<br />
<code>java.nio.file.NoSuchFileException: /mnt/ramdisk/alluxioworker</code></p>
<p>直接创建<code>mkdir -p /mnt/ramdisk/alluxioworker</code></p>
<ol start="5">
<li>启动Alluxio</li>
</ol>
<p><code>./bin/alluxio-start.sh local SudoMount</code></p>
<p>这时候就能够直接看到Alluxio的Web UI了，这里可以把云服务器的安全组策略改一下，让19999端口暴露出来，这样就能直接访问 <code>公网IP:19999</code> 看到Web UI了。</p>
<h3><a id="%E5%A4%9A%E6%9C%BA%E7%8E%AF%E5%A2%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>多机环境</h3>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RocketMQ安装与实践]]></title>
    <link href="chaoranlaoge.top/16465400869241.html"/>
    <updated>2022-03-06T12:14:46+08:00</updated>
    <id>chaoranlaoge.top/16465400869241.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装指南</h2>
<ol>
<li>上官网下载安装包 <code>rocketmq-all-4.4.0-bin-release.zip</code></li>
<li>放到用户目录下，解压压缩包，并进入目录</li>
<li>修改配置文件</li>
</ol>
<pre><code class="language-shell">cd bin

vim runserver.sh 
# 找到如下配置
JAVA_OPT=&quot;${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g&quot;
# 修改成你可以接受的范围
JAVA_OPT=&quot;${JAVA_OPT} -server -Xms512m -Xmx521m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;

vim runbroker.sh
# 找到如下配置
JAVA_OPT=&quot;${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;
# 修改成你可以接受的范围
JAVA_OPT=&quot;${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn256m&quot;
</code></pre>
<ol start="4">
<li>配置环境变量</li>
</ol>
<pre><code class="language-shell">vim /etc/profile

# 将如下配置加到最后一行
export NAMESRV_ADDR=127.0.0.1:9876

# 使配置生效
source /etc/profile
</code></pre>
<ol start="5">
<li>将rocketmq文件夹放到<code>/usr/local</code>目录下，并进入文件夹</li>
</ol>
<pre><code class="language-shell">mv -R ~/rocketmq /usr/local/rocketmq
cd /usr/local/rocketmq
</code></pre>
<ol start="6">
<li>启动nameserver和mqbroker</li>
</ol>
<pre><code class="language-shell">nohup sh bin/mqnamesrv &amp;

nohup sh bin/mqbroker -n localhost:9876 &amp;
</code></pre>
<h3><a id="%E5%AE%89%E8%A3%85rocketmq-console" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装RocketMQ Console</h3>
<ol>
<li>下载rocketmq-external</li>
</ol>
<pre><code class="language-shell">cd /usr/local/rocketmq

git clone https://github.com/apache/rocketmq-externals
</code></pre>
<ol start="2">
<li>安装Maven来打包</li>
</ol>
<pre><code class="language-shell">sudo yum install -y maven
</code></pre>
<ol start="3">
<li>需要查看一下RocketMQ的Console的pom.xml，改动依赖项</li>
</ol>
<pre><code class="language-shell">
</code></pre>
<ol start="4">
<li>用Maven打包</li>
</ol>
<pre><code class="language-shell">cd /usr/local/rocketmq/rocketmq-externals/rocketmq-console

mvn clean package -Dmaven.test.skip=true
</code></pre>
<ol start="5">
<li>启动RocketMQ-console</li>
</ol>
<h3><a id="%E9%85%8D%E7%BD%AErocketmq%E4%B8%BA%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置RocketMQ为开机自启动服务</h3>
<p>参考博客</p>
<h3><a id="%E5%AE%89%E8%A3%85q-a" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装 Q&amp;A</h3>
<h4><a id="q-native-memory-allocation-mmap-failed-to-map-2147483648-bytes-for-committing-reserved-memory" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Q: Native memory allocation (mmap) failed to map 2147483648 bytes for committing reserved memory.</h4>
<pre><code class="language-shell">Java HotSpot(TM) 64-Bit Server VM warning: Using the DefNew young collector with the CMS collector is deprecated and will likely be removed in a future release
Java HotSpot(TM) 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.
Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x00000006ec800000, 2147483648, 0) failed; error='Cannot allocate memory' (errno=12)
#
# There is insufficient memory for the Java Runtime Environment to continue.
# Native memory allocation (mmap) failed to map 2147483648 bytes for committing reserved memory.
# An error report file with more information is saved as:
# /home/centos/rocketmq-all-4.4.0-bin-release/hs_err_pid5064.log
</code></pre>
<p>A:</p>
<pre><code class="language-shell">原因
默认运行内存设置过大，我查看我的好多默认设置都是大于1G ，甚至有的是 2G 、4G ....

解决
修改目录 /distribution/target/apache-rocketmq/bin 下的 3 个配置文件： runserver.sh、runbroker.sh 、tools.sh 。
设置 runserver.sh 中此项配置 为：

JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn512m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;
设置 runbroker.sh 中此项配置 为：

 JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m&quot;
（我改了 runserver.sh、runbroker.sh 依旧不行，后来注意到 tools.sh 中也有配置，3个都改就行了）

设置 tools.sh 中此项配置 为：

JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn256m -XX:PermSize=128m -XX:MaxPermSize=128m&quot;
完成以上操作，后续测试就成功运行了。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RocketMQ知识点]]></title>
    <link href="chaoranlaoge.top/16464625257370.html"/>
    <updated>2022-03-05T14:42:05+08:00</updated>
    <id>chaoranlaoge.top/16464625257370.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#producer%E7%9F%A5%E8%AF%86%E7%82%B9">Producer知识点</a>
<ul>
<li><a href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%BB%84">生产者组</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E6%96%B9%E5%BC%8F">发送方式</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E8%BF%94%E5%9B%9E%E7%A0%81">消息返回码</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B">消息类型</a>
<ul>
<li><a href="#%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF">普通顺序消息</a></li>
<li><a href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF">延迟消息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B6%88%E6%81%AFmessage%E7%9F%A5%E8%AF%86%E7%82%B9">消息Message知识点</a>
<ul>
<li><a href="#%E4%B8%A5%E6%A0%BC%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF">严格顺序消息</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF">顺序消息</a></li>
</ul>
</li>
<li><a href="#%E6%A0%87%E7%AD%BEtag%E7%9F%A5%E8%AF%86%E7%82%B9">标签Tag知识点</a></li>
</ul>

<h2><a id="producer%E7%9F%A5%E8%AF%86%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Producer知识点</h2>
<p>RocketMQ的消息发送方，叫做Producer（生产者）。一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。</p>
<h3><a id="%E7%94%9F%E4%BA%A7%E8%80%85%E7%BB%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生产者组</h3>
<p>RocketMQ设计了一个Producer Group（生产者组）的概念，这类Producer发送同一类消息且发送逻辑一致。</p>
<p>生产者组的意义在于互备，如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<h3><a id="%E5%8F%91%E9%80%81%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发送方式</h3>
<p>RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<p>消息发送典型的形式是同步发送和异步发送。同步发送，调用的就是<code>send</code>方法。异步发送，也是<code>send</code>方法，但是需要创建<code>SendCallBack</code>，来重写<code>onSuccess</code>和<code>onException</code>两个方法。</p>
<p>单向发送，调用的是<code>sendOneWay</code>方法，调用之后没有任何返回结果。主要是用在不关心发送结果的场景，比如日志发送。</p>
<h3><a id="%E6%B6%88%E6%81%AF%E8%BF%94%E5%9B%9E%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息返回码</h3>
<p>当Producer采用同步或者异步发送方式时，都需要处理Broker的返回码，返回码包括以下几种：</p>
<ul>
<li>FLUSH_DISK_TIMEOUT 没有在规定时间刷盘</li>
<li>FLUSH_SLAVE_TIMEOUT 没有在设定时间内完成主从同步（这种是在Broker主从同步方式设置成SYNC_MASTER时才有的）</li>
<li>SLAVE_NOT_AVAILABLE 没有找到被配置成Slave的Broker节点（这种是在Broker主从同步方式设置成SYNC_MASTER时才有的）</li>
<li>SEND_OK 发送成功</li>
</ul>
<p>第二种和第三种是基本一致的</p>
<h3><a id="%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息类型</h3>
<h4><a id="%E6%99%AE%E9%80%9A%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>普通顺序消息</h4>
<p>RocketMQ按发送过程，可以将消息类型可以分成三种：顺序消息，延迟消息，事务消息</p>
<p>顺序消息，是指Producer发送时，默认情况下是采取Round Robin轮询方式把消息发送到Topic下的不同的queue（分区队列），如果说queue只有一个，那么消息就是Topic下全局有序的，又如果说queue有多个，那么消息是分区有序，即只在当前queue里有序。</p>
<h4><a id="%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>延迟消息</h4>
<p>延迟消息，是指Producer发送给Broker之后，Broker会延迟一段时间再处理，使消息在用户设置的延迟时间之后才生效。</p>
<p>使用方法，是在创建<code>Message对象</code>时，调用<code>setDelayTimeLevel(int level)</code>方法设置延迟时间，目前延迟的时间不支持任意设置，仅支持一些预设置的时间长度，这个预设置是在Broker配置，注意是全局生效（所有topic共用）。默认的值是<code>“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”</code>，一共18个级别。当级别为0时，表示非延迟消息，如果<code>level</code>大于等于18，也按最大的值计算。</p>
<p>定时消息会暂存在名为<code>SCHEDULE_TOPIC_XXXX</code>的topic中，并根据<code>delayTimeLevel</code>存入特定的queue，<code>queueId = delayTimeLevel – 1</code>，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费<code>SCHEDULE_TOPIC_XXXX</code>，将消息写入真实的topic。</p>
<h2><a id="%E6%B6%88%E6%81%AFmessage%E7%9F%A5%E8%AF%86%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息Message知识点</h2>
<p>RocketMQ消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。</p>
<p>RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<h3><a id="%E4%B8%A5%E6%A0%BC%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>严格顺序消息</h3>
<p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<h3><a id="%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>顺序消息</h3>
<p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>
<h2><a id="%E6%A0%87%E7%AD%BEtag%E7%9F%A5%E8%AF%86%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>标签Tag知识点</h2>
<p>用于同一主题下区分不同类型的消息。</p>
<p>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。</p>
<p>标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。</p>
<p>消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RocketMQ源码解读]]></title>
    <link href="chaoranlaoge.top/16464531729826.html"/>
    <updated>2022-03-05T12:06:12+08:00</updated>
    <id>chaoranlaoge.top/16464531729826.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#nameserver%E6%BA%90%E7%A0%81">NameServer源码</a></li>
<li><a href="#producer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB">Producer源码解读</a>
<ul>
<li><a href="#producer%E5%9C%A8%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9F">Producer在框架中的类定义关系是？</a></li>
</ul>
</li>
<li><a href="#consumer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB">Consumer源码解读</a>
<ul>
<li><a href="#consumer%E5%9C%A8%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9F">Consumer在框架中的类定义关系是？</a></li>
</ul>
</li>
</ul>

<h2><a id="nameserver%E6%BA%90%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NameServer源码</h2>
<p>画了<a href="https://www.processon.com/view/link/6222ff675653bb07282706fa">PorcessOn-RocketMQ4.4-NameServer流程图</a></p>
<p>从代码写法上来说，有几点疑问：</p>
<ul>
<li><code>MixAll</code>这个类，不知道设计来干啥的？而且金山的代码有使用到这个，不知道具体用法？</li>
<li>命令行解析的写法值得借鉴，我感觉需要看一下最新的代码，看这块有无改进？</li>
<li><code>RocketMQ</code>是如何支持多种日志框架的？</li>
</ul>
<h2><a id="producer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Producer源码解读</h2>
<h3><a id="producer%E5%9C%A8%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Producer在框架中的类定义关系是？</h3>
<p>最基础的Producer接口是<code>MQProducer</code><br />
<code>client</code>包中有两个类实现这个接口</p>
<ul>
<li><code>DefaultMQProducer</code> 线程安全<br />
<img src="media/16464625257370/16465373770738.jpg" alt="" /></li>
<li><code>TransactionMQProducer</code> 用于事务消息<br />
<img src="media/16464625257370/16465374078801.jpg" alt="" /></li>
</ul>
<p>最主要的就是<code>send</code>方法</p>
<p>这个需要查看<code>example</code>的代码来实践用法</p>
<h2><a id="consumer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Consumer源码解读</h2>
<h3><a id="consumer%E5%9C%A8%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Consumer在框架中的类定义关系是？</h3>
<p>最基础的Consumer接口是<code>MQConsumer</code><br />
<code>client</code>包有两个接口继承这个接口</p>
<ul>
<li><code>MQPullConsumer</code> 用于Pull方式的消费者</li>
<li><code>MQPushConsumer</code> 用于Push方式的消费者</li>
</ul>
<p>其中，Push方式的类继承比较直接，是<code>DefaultMQPushConsumer</code><br />
<img src="media/16464625257370/16465390123470.jpg" alt="" /></p>
<p>而Pull方式的类继承就有一点绕，本来是<code>DefaultMQPullConsumer</code><br />
<img src="media/16464625257370/16465390763066.jpg" alt="" /><br />
但是按照代码注释来看，这个类被禁用了，2022年会被移除，在Pull方式下，官方建议使用<code>DefaultLitePullConsumer</code><br />
<img src="media/16464625257370/16465391440469.jpg" alt="" /><br />
但是奇怪的是，<code>LitePullConsumer</code>并没有实现<code>MQConsumer</code>的接口</p>
<p>最主要的还是<code>registerMessageListener</code>方法</p>
<p>其中方法参数是<code>MessageListener</code>消息监听者接口<br />
继承该接口的接口是<code>MessageListenerConcurrently</code>,继承关系如下<br />
<img src="media/16464531729826/16465399880336.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[速读摘要]]></title>
    <link href="chaoranlaoge.top/16462210956998.html"/>
    <updated>2022-03-02T19:38:15+08:00</updated>
    <id>chaoranlaoge.top/16462210956998.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%B8%8E%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0">数据中台与硅谷大数据平台</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0">第一章</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0">第二章</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0">第三章</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0todo">第四章[TODO]</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%92%8C%E6%96%B9%E6%B3%95%E8%AE%BA">数据中台架构和方法论</a>
<ul>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0todo">第五章[TODO]</a></li>
<li><a href="#%E7%AC%AC%E5%85%AD%E7%AB%A0todo">第六章[TODO]</a></li>
<li><a href="#%E7%AC%AC%E4%B8%83%E7%AB%A0todo">第七章[TODO]</a></li>
<li><a href="#%E7%AC%AC%E5%85%AB%E7%AB%A0">第八章</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9">数据中台技术选型与核心内容</a>
<ul>
<li><a href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0todo">第九章[TODO]</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%E9%AB%98%E4%BC%98">第十章[高优]</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0todo">第十一章[TODO]</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E9%AB%98%E4%BC%98">第十二章[高优]</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E9%AB%98%E4%BC%98">第十三章[高优]</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0todo">第十四章[TODO]</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0todo">第十五章[TODO]</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90">数据中台案例分析</a>
<ul>
<li><a href="#%E5%8D%81%E5%85%AD%E7%AB%A0">十六章</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0">第十七章</a></li>
<li><a href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0">第十八章</a></li>
</ul>
</li>
</ul>

<h2><a id="%E5%89%8D%E8%A8%80" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>前言</h2>
<p>作者彭峰，留美博士，在08年左右就开始做以开源Hadoop替换Oracle，并在此之上做了一系列数据驱动产品，满足了不断增长的数据产品需求。</p>
<p>普遍认同的数据中台的任务：大同企业各个部门之间的数据，形成<strong>统一的数据开发和使用规范</strong>，在企业各个部门之间实现数据能力的<strong>抽象、共享和复用</strong>。</p>
<p>数据中台的价值更多体现在<strong>与业务结合的能力矩阵</strong>，而不是简单的数据标准化和报表工具上。数据中台一般使用数据湖来存储可以反应全局业务情况的原始数据，能够对核心业务流程进行更全面、更深入的分析，并在此基础上加快对市场的认识和反应，降低产品研发和试错的成本，缩短时间。</p>
<p>数据中台的一个<strong>天然特性</strong>是支持多元异构的数据以及处理这些数据的工具。为了避免不断建设独立的系统形成数据孤岛，利用云原生架构能够快速地扩展服务节点，简化了统一数据规范的工作。</p>
<p><strong>建设数据中台的目的</strong>在于，深刻理解当前的业务流程，提出优化建议并提供能力支持。</p>
<p><strong>数据中台应采取业务驱动、快速落地、小步快跑的方式</strong>，在这个过程中，使用合适的指标体系衡量数据中台的投入产出比，以及提供合适的工具赋能业务部门，有助于数据中台得到业务部门的支持和认可，顺利完成中台的实施。</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E4%B8%8E%E7%A1%85%E8%B0%B7%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据中台与硅谷大数据平台</h2>
<h3><a id="%E7%AC%AC%E4%B8%80%E7%AB%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一章</h3>
<p>建设数据中台的最终目标是通过高效的数字化运营，实现“快速市场响应，精细化运营，开源节流”</p>
<p>所有数据工具的建设目的都是从数据中提取<strong>价值</strong>来支持更有效的数字化运营。所谓价值，就是BI（Business Intelligence）和AI。</p>
<p>数据中台有一个比传统大数据平台和数据仓库层次更高的要求：实现数据能力的全局抽象、共享和复用。</p>
<p>如何实现数据中台建设目标：</p>
<ul>
<li>有从数据中产生价值的能力，必须有高效好用的数据处理工具</li>
<li>要有全局的数据汇聚和治理，需要完成统一的数据规范</li>
<li>对数据处理能力的抽象，实现能力的复用和共享
<ul>
<li>顶层设计后进行推广</li>
<li>由实际需求设计再进行进一步抽象推广</li>
</ul>
</li>
<li>协调复用和效率的矛盾，需要有一套工具来精确衡量数据能力的ROI（投入产出比）</li>
</ul>
<p>数据中台的特点：</p>
<ul>
<li>汇聚全局的数据为用户赋能</li>
<li>实现数据能力的抽象</li>
<li>通过工具体系让企业各部门共享抽象的数据能力</li>
<li>高效地管理数据能力并加以复用</li>
</ul>
<p>大数据平台 转型为 数据中台的几点考量 （P18）</p>
<p>大数据平台的架构图（P20）</p>
<p>数据中台应该是大数据平台的一个超集：</p>
<ul>
<li>全局的数据应用资产管理</li>
<li>全局的数据治理机制</li>
<li>自助的、多租户的数据应用开发及发布</li>
<li>数据应用的CI/CD</li>
<li>新的数据应用技术框架的快速集成</li>
<li>数据即服务，模型即服务（无代码的方式发布）</li>
<li>数据能力共享管理</li>
<li>完善的运营指标</li>
<li>阿里巴巴提出的OneID，OneModel，OneService</li>
<li>TotalPlatform，不允许数据孤岛和局部数据</li>
<li>TotalInsight，用户可以轻松理解全局的数据资产和能力</li>
</ul>
<p>数据中台的五大要求（P23）</p>
<p>数据中台建设方法论要点：</p>
<ol>
<li>业务驱动，快速落地</li>
<li>顶层架构设计及数据规范</li>
<li>平台管理</li>
<li>明确得到责权利制定</li>
<li>必须是一个安全、高效、稳定、可扩展的系统</li>
</ol>
<p>第六章详细介绍阐述，数据中台建设的一整套技术和方法论</p>
<h3><a id="%E7%AC%AC%E4%BA%8C%E7%AB%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第二章</h3>
<p>数字中台不是银弹，数字中台的成果是建立在信息化的基础上的，没有完善的信息化基础，企业就无法全面理解企业业务。</p>
<p>数据中台是企业进入更高级管理阶段的一个标志。</p>
<p>数据中台的核心能力（P31）</p>
<ul>
<li>全局商业洞见</li>
<li>个性化服务</li>
<li>实时数据报表</li>
<li>共享能力开发新业务</li>
</ul>
<p>数据中台的行业应用场景（P41）</p>
<ul>
<li>互联网行业</li>
<li>连锁零售业</li>
<li>金融业</li>
<li>物联网</li>
</ul>
<p>数据中台如何为企业赋能（P45）</p>
<ul>
<li>组织架构</li>
<li>决策部门</li>
<li>业务部门</li>
<li>研发部门</li>
<li>大数据部门</li>
</ul>
<h3><a id="%E7%AC%AC%E4%B8%89%E7%AB%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三章</h3>
<p>主要是讲数字化转型，数字驱动的案例，数字中台支持数字化转型的做法</p>
<h3><a id="%E7%AC%AC%E5%9B%9B%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第四章[TODO]</h3>
<p>主要是讲从大数据平台到数据中台的建设</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<hr />
<h2><a id="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%9E%B6%E6%9E%84%E5%92%8C%E6%96%B9%E6%B3%95%E8%AE%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据中台架构和方法论</h2>
<h3><a id="%E7%AC%AC%E4%BA%94%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第五章[TODO]</h3>
<p>主要是讲数据中台建设的教训和问题，如何评判效果，以及人员规划，技术选型</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<h3><a id="%E7%AC%AC%E5%85%AD%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第六章[TODO]</h3>
<p>主要是讲建设数据中台的方法论，有几个比较关注的就是，数据规范，数据驱动，关键指标，责权利怎么界定，管理迭代等重点问题</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<h3><a id="%E7%AC%AC%E4%B8%83%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第七章[TODO]</h3>
<p>以具体案例，讲解了典型的硅谷大数据平台架构，这个可以参考架构思路</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<h3><a id="%E7%AC%AC%E5%85%AB%E7%AB%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第八章</h3>
<p>主要是安利在云原生架构之下建设数据中台，比较偏理论和阐述观点</p>
<h2><a id="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E4%B8%8E%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据中台技术选型与核心内容</h2>
<h3><a id="%E7%AC%AC%E4%B9%9D%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第九章[TODO]</h3>
<p>主要是列出数据中台的各领域的开源软件，给技术选型用以参考</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<h3><a id="%E7%AC%AC%E5%8D%81%E7%AB%A0%E9%AB%98%E4%BC%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十章[高优]</h3>
<p>主要是讲解数据湖和数据仓库，有空结合一下行内的数据湖和数据仓库的材料看一下</p>
<p><strong>【高优先】 近期要着重看一下这章节</strong></p>
<h3><a id="%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十一章[TODO]</h3>
<p>数据资产管理，主要是讲解概念，定义和数据资产的ROI</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<h3><a id="%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E9%AB%98%E4%BC%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十二章[高优]</h3>
<p>数据流水线管理，主要专业相关，侧重查看这个章节</p>
<p><strong>【高优先】 近期要着重看一下这章节</strong></p>
<h3><a id="%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E9%AB%98%E4%BC%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十三章[高优]</h3>
<p>数据应用开发，主要是讲解了应用侧的，实际上和我们数据集成做的工作比较相关，我们做的调度系统也比较偏向于应用调度系统，这个可以参考借鉴</p>
<p><strong>【高优先】 近期要着重看一下这章节</strong></p>
<h3><a id="%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十四章[TODO]</h3>
<p>数据门户，主要是安利了，这个主要是看他怎么做社交属性和智能运维</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<h3><a id="%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0todo" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十五章[TODO]</h3>
<p>数据中台演进，主要是看关键指标</p>
<p><em>【TODO】 有空要着重看一下这章节</em></p>
<h2><a id="%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据中台案例分析</h2>
<h3><a id="%E5%8D%81%E5%85%AD%E7%AB%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>十六章</h3>
<p>介绍EA数据中台</p>
<h3><a id="%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十七章</h3>
<p>介绍零售业的数据中台</p>
<h3><a id="%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第十八章</h3>
<p>介绍物联网领域数据中台</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消息队列学习笔记]]></title>
    <link href="chaoranlaoge.top/16460146780363.html"/>
    <updated>2022-02-28T10:17:58+08:00</updated>
    <id>chaoranlaoge.top/16460146780363.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0">消息队列概述</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B">消息模型</a>
<ul>
<li><a href="#%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B">队列模型</a>
<ul>
<li><a href="#%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">队列模型存在的问题</a></li>
</ul>
</li>
<li><a href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B%EF%BC%88publish-subscribe-pattern%EF%BC%89">发布-订阅模型（Publish-Subscribe Pattern）</a></li>
<li><a href="#rabbitmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B">RabbitMQ的消息模型</a></li>
<li><a href="#rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B">RocketMQ的消息模型</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">事务消息</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1">消息丢失</a></li>
<li><a href="#%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF">重复消息</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B">消息积压</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%87%AA%E6%9F%A5q-a">消息队列自查Q&amp;A</a></li>
</ul>

<h2><a id="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息队列概述</h2>
<ul>
<li>消息队列适合解决什么问题？</li>
</ul>
<ol>
<li>异步处理</li>
<li>流量控制</li>
<li>解耦应用</li>
<li>消息分发</li>
</ol>
<ul>
<li>使用消息队列的问题和局限性</li>
</ul>
<ol>
<li>引入消息队列带来的延迟问题</li>
<li>增加了系统的复杂度</li>
<li>可能产生数据不一致的问题</li>
</ol>
<ul>
<li>可供选择的开源消息队列产品：</li>
</ul>
<ol>
<li>老牌儿消息队列 RabbitMQ，俗称兔子 MQ。</li>
</ol>
<blockquote>
<p>RabbitMQ 一个比较有特色的功能是支持非常灵活的<strong>路由配置</strong>，和其他消息队列不同的是，它在生产者（Producer）和队列（Queue）之间增加了一个 <strong>Exchange 模块</strong>，你可以理解为交换机。这个 Exchange 模块的作用和交换机也非常相似，根据配置的路由规则将生产者发出的消息分发到不同的队列中。路由的规则也非常灵活，甚至你可以自己来实现路由规则。基于这个 Exchange，可以产生很多的玩儿法，如果你正好需要这个功能，RabbitMQ 是个不错的选择。</p>
<p>RabbitMQ有几个问题：1. 对消息堆积的支持并不好，大量消息堆积会导致RabbitMQ性能急剧下降。2. RabbitMQ性能比RocketMQ和Kafka都差，如果应用对消息队列性能要求非常高，不要选择RabbitMQ。3. RabbitMQ使用Erlang开发，不好做二次开发或拓展。</p>
</blockquote>
<ol start="2">
<li>RocketMQ 是阿里巴巴在 2012 年开源的消息队列产品，后来捐赠给 Apache 软件基金会，2017 正式毕业，成为 Apache 的顶级项目。</li>
</ol>
<blockquote>
<p>RocketMQ 就像一个品学兼优的好学生，有着不错的性能，稳定性和可靠性，具备一个现代的消息队列应该有的几乎全部功能和特性，并且它还在持续的成长中。</p>
<p>RocketMQ 对在线业务的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应，如果你的应用场景很在意响应时延，那应该选择使用 RocketMQ。每秒钟大概能处理几十万条消息。</p>
<p>RocketMQ 的一个劣势是，作为国产的消息队列，相比国外的比较流行的同类产品，在国际上还没有那么流行，与周边生态系统的集成和兼容程度要略逊一筹。</p>
</blockquote>
<ol start="3">
<li>Kafka 最早是由 LinkedIn 开发，目前也是 Apache 的顶级项目。Kafka 最初的设计目的是用于处理海量的日志。</li>
</ol>
<blockquote>
<p>Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。</p>
<p>Kafka 使用 Scala 和 Java 语言开发，设计上大量使用了批量和异步的思想，这种设计使得 Kafka 能做到超高的性能。Kafka 的性能，尤其是异步收发的性能，是三者中最好的，但与 RocketMQ 并没有量级上的差异，大约每秒钟可以处理几十万条消息。</p>
<p>但是 Kafka 这种<strong>异步批量</strong>的设计带来的问题是，它的同步收发消息的响应时延比较高，因为当客户端发送一条消息的时候，Kafka 并不会立即发送出去，而是要等一会儿攒一批再发送，在它的 Broker 中，很多地方都会使用这种“先攒一波再一起处理”的设计。当你的业务场景中，每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。</p>
</blockquote>
<ol start="4">
<li>Pulsar是一个新兴的开源消息队列产品，最早是由 Yahoo 开发，目前处于成长期，流行度和成熟度相对没有那么高。与其他消息队列最大的不同是，Pulsar 采用存储和计算分离的设计.</li>
</ol>
<p>总结：如果只是需要一个开箱即用易于维护的产品，建议用RabbitMQ。如果主要常见在于处理在线业务，RocketMQ的低延迟和金融级的稳定性是需要的。如果需要处理海量消息，Kafka异步处理比较适合。</p>
<h2><a id="%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息模型</h2>
<h3><a id="%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>队列模型</h3>
<p><img src="media/16460146780363/16460294424686.jpg" alt="" /></p>
<blockquote>
<p>早期的消息队列，就是按照“队列”的数据结构来设计的。我们一起看下这个图，生产者（Producer）发消息就是入队操作，消费者（Consumer）收消息就是出队也就是删除操作，服务端存放消息的容器自然就称为“队列”。</p>
</blockquote>
<h4><a id="%E9%98%9F%E5%88%97%E6%A8%A1%E5%9E%8B%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>队列模型存在的问题</h4>
<p>多个生产者往消息队列里面发送消息，消费者能够消费到的消息就是这些生产者生产的所有消息的合计。消息的顺序就是这些生产者发送消息的自然顺序。</p>
<p>但如果有多个消费者接受同一个队列的消息，这些消费者之间实际上是竞争的关系，每个消费者只能收到队列中的一部分消息，也就是说任何一条消息只能被其中一个消费者收到。</p>
<p>如果需要将一份消息数据分发给多个消费者，要求每个消费者都能收到这个消息，比如一份订单数据，风控系统、分析系统、支付系统等都需要接收消息。这个时候，单个队列就满足不了需求，一个可行的解决方式是，为每个消费者创建一个单独的队列，让生产者发送多份。这样会耗费大量资源，而且生产者必须知道有多少个消费者，这样他才能为每个消费者单独发送一份消息，这实际上违背了消息队列“解耦”的这个设计。</p>
<h3><a id="%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B%EF%BC%88publish-subscribe-pattern%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>发布-订阅模型（Publish-Subscribe Pattern）</h3>
<p><img src="media/16460146780363/16460295367852.jpg" alt="" /></p>
<p>在发布 - 订阅模型中，消息的发送方称为<strong>发布者</strong>（Publisher），消息的接收方称为<strong>订阅者</strong>（Subscriber），服务端存放消息的容器称为<strong>主题</strong>（Topic）。</p>
<p>发布者将消息发送到主题中，订阅者在接收消息之前需要先“订阅主题”。“订阅”在这里既是一个<strong>动作</strong>，同时还可以认为是主题在消费时的一个<strong>逻辑副本</strong>，每份订阅中，订阅者都可以接收到主题的所有消息。</p>
<ul>
<li>队列模型和发布-订阅模型最大的区别：一份消息数据能不能被消费多次的问题。</li>
<li>队列模型和发布-订阅模型：如果只有一个订阅者，发布-订阅模型就是队列模型。</li>
</ul>
<h3><a id="rabbitmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RabbitMQ的消息模型</h3>
<p><img src="media/16460146780363/16460298278837.jpg" alt="" /></p>
<p>在 RabbitMQ 中，Exchange 位于生产者和队列之间，生产者并不关心将消息发送给哪个队列，而是将消息发送给 Exchange，由 Exchange 上配置的策略来决定将消息投递到哪些队列中。</p>
<ul>
<li>RabbitMQ消息模型如何实现发布-订阅模型？</li>
</ul>
<p><strong>Exchange配置消息发送到多个队列，变相实现一份消息消费多次的发布-订阅模型。</strong></p>
<p>同一份消息如果需要被多个消费者来消费，需要配置 Exchange 将消息发送到多个队列，每个队列中都存放一份完整的消息数据，可以为一个消费者提供消费服务。这也可以变相地实现新发布 - 订阅模型中，“一份消息数据可以被多个订阅者来多次消费”这样的功能。</p>
<h3><a id="rocketmq%E7%9A%84%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>RocketMQ的消息模型</h3>
<p>RocketMQ 使用的消息模型是标准的发布 - 订阅模型，但是，在 RocketMQ 也有队列（Queue）这个概念，并且队列在 RocketMQ 中是一个非常重要的概念。<strong>RocketMQ消息模型中，每个主题中包含了多个队列，通过多个队列来实现多实例并行生产和消费。</strong></p>
<p><img src="media/16460146780363/16460300018938.jpg" alt="" /></p>
<ul>
<li>什么是“请求 - 确认”机制？</li>
</ul>
<p>几乎所有的消息队列产品都使用一种非常朴素的“请求 - 确认”机制，确保消息不会在传递过程中由于网络或服务器故障丢失。在生产端，生产者先将消息发送给服务端，也就是 Broker，服务端在收到消息并将消息写入主题或者队列中后，会给生产者发送确认的响应。如果生产者没有收到服务端的确认或者收到失败的响应，则会重新发送消息；在消费端，消费者在收到消息并完成自己的消费业务逻辑（比如，将数据保存到数据库中）后，也会给服务端发送消费成功的确认，服务端只有收到消费确认后，才认为一条消息被成功消费，否则它会给消费者重新发送这条消息，直到收到对应的消费成功确认。</p>
<ul>
<li>“请求-确认”机制会给消费端带来什么问题？</li>
</ul>
<p>在某一条消息被成功消费之前，下一条消息是不能被消费的，否则就会出现<strong>消息空洞</strong>，违背了有序性的原则。也就是说，<strong>发布-订阅模型中每个主题在任意时刻，至多只能有一个消费者实例在进行消费</strong>，那就无法通过水平扩展消费者的数量来提升提升消费端总体的消费性能。</p>
<ul>
<li>RocketMQ消息模型与发布-订阅模型的不同点</li>
</ul>
<p><strong>RocketMQ 只在队列上保证消息的有序性</strong>，主题层面是无法保证消息的严格顺序的。RocketMQ 中，订阅者的概念是通过消费组（Consumer Group）来体现的。<strong>每个消费组都消费主题中一份完整的消息，不同消费组之间消费进度彼此不受影响</strong>，也就是说，一条消息被 Consumer Group1 消费过，也会再给 Consumer Group2 消费。在 Topic 的消费过程中，由于消息需要被不同的组进行多次消费，所以<strong>消费完的消息并不会立即被删除</strong>，这就需要 RocketMQ 为每个消费组在每个队列上维护一个<strong>消费位置（Consumer Offset）</strong>，这个位置之前的消息都被消费过，之后的消息都没有被消费过，每成功消费一条消息，消费位置就加一。这个消费位置是非常重要的概念，我们在使用消息队列的时候，丢消息的原因大多是由于消费位置处理不当导致的。</p>
<ul>
<li>Kafka和RocketMQ消息模型的异同</li>
</ul>
<p>Kafka和RocketMQ在消息模型上是完全一致的，唯一的区别在于，RocketMQ中主题里面有分多个队列，而Kafka中队列的概念对应名称是“<strong>分区</strong>”。</p>
<h2><a id="%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>事务消息</h2>
<p>分布式事务的4个属性：ACID特性，原子性、一致性、隔离性、持久性</p>
<p>比较常见的分布式事务：2PC（Two-phase commit，二阶段提交）TCC（Try-Confirm-Cancle）和事务消息。</p>
<p>事务消息适用的常见主要是<strong>那些需要异步更新数据，并且对数据实时性要求不太高的场景。</strong></p>
<ul>
<li>消息队列如何实现分布式事务？</li>
</ul>
<p><img src="media/16460146780363/16462014497198.jpg" alt="" /></p>
<ol>
<li>订单系统在消息队列上<strong>开启一个事务</strong></li>
<li>订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，<strong>在事务提交之前，对于消费者来说，这个消息是不可见的。</strong></li>
<li>半消息发送成功后，订单系统就可以<strong>执行本地事务</strong>了，在订单库中创建一条订单记录，并提交订单库的数据库事务。</li>
<li>如果订单创建成功，那就<strong>提交事务消息</strong>，购物车系统就可以<strong>消费到这条消息</strong>继续后续的流程。如果订单创建失败，那就<strong>回滚事务消息</strong>，购物车系统就不会收到这条消息。</li>
</ol>
<p>第四步可能会出现提交事务消息失败，此时还是会出现不满足一致性要求的问题，</p>
<ul>
<li>Kafka和RocketMQ如何处理提交事务消息失败导致事务消息不满足一致性要求的问题？</li>
</ul>
<p>Kafka和RocketMQ都提供了相应的解决方案。如果提交事务消息失败，Kafka会直接抛出异常，让用户自行处理。在业务代码里，我们可以反复重试提交，直到提交成功，或者回退之前的本地处理。</p>
<p>RocketMQ给出另外一种解决方案，RocketMQ增加了事务反查的机制来解决事务消息提交失败的问题。如果生产者在提交或者回滚事务消息时发生网络异常，RocketMQ的Broker没有收到提交或者回滚的要求，Broker会定期去Producer上反查这个事务对应的本地事务的状态，然后根据反查结果决定提交或者回滚这个事务。</p>
<p>为了支撑这个事务反查机制，我们的业务代码需要实现一个<strong>反查本地事务状态的接口</strong>，告知<strong>RocketMQ本地事务是成功还是失败，这个本地事务的实现，并不依赖消息的发送方</strong>，这种情况下，即使是发送事务消息的生产者节点宕机了，RocketMQ仍然可以通过其他生产者节点来执行反查，确保事务的完整性。</p>
<p><img src="media/16460146780363/16462014735098.jpg" alt="" /></p>
<ul>
<li>相比于原来的事务消息实现，RocketMQ有何不同点？</li>
</ul>
<p>RocketMQ对于第四步提交或回滚事务失败，能够实现本地事务反查机制，来根据本地事务的反查结果决定最后是否投递或者回滚事务消息。</p>
<h2><a id="%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息丢失</h2>
<ul>
<li>如何检测消息丢失？</li>
</ul>
<p>IT基础设施比较完善的公司，一般都有<strong>分布式链路追踪系统</strong>，使用类似的追踪系统可以很方便地追踪每一条消息。但如果没有这样的追踪系统，我们可以<strong>利用消息队列的有序性来验证是否有消息丢失</strong>。</p>
<p>我们给生产者节点发出的消息都附加一个连续递增的序号，然后在消费者节点来检查这个序号的连续性。如果消息没有丢失，序号必然是连续的，如果消息丢失了，那么就是丢消息了，还可以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。</p>
<p>大多数消息队列的客户端都支持拦截器机制，可以利用这个机制将序号注入到消息中，在消费者节点收到消息的拦截器中检测序号的连续性，这样实现的好处是消息检测的代码不会侵入到业务代码，待系统稳定后，也方便讲这部分检测的逻辑关闭或者删除。</p>
<p>以上是针对单机系统实现的消息丢失检测方法，对于分布式系统要实现这个消息丢失检测方法，还有几个问题：</p>
<ol>
<li>Kafka和RocketMQ这些消息队列，不保证Topic上的严格顺序，只能保证分区（队列）上的消息是有序的，所以我们在发消息的时候，要指定分区（队列），并且每个分区单独检测消息序号的连续性。</li>
<li>如果系统的生产者节点是多实例的，由于并不好协调多个生产者端消息的发送顺序，所以也需要每个生产者分别生产各自的消息序号，并且需要附加上生产者节点的标识，在消费者端按照每个生产者来分别检测序号的连续性。</li>
<li>消费者节点的数量最好和分区数量一致，做到消费者和分区一一对应，这样比较好单独处理每一个分区。</li>
</ol>
<ul>
<li>日常使用中如何保证不会丢失消息？</li>
</ul>
<ol>
<li>
<p>生产阶段，生产者节点一定要根据请求确认机制，发送消息之后要正确处理返回值或者捕获异常，就可以保证这个阶段消息不会丢失。</p>
</li>
<li>
<p>存储阶段，如果Broker出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失信息。如果对消息的可靠性要求非常高，可以通过配置Broker参数来避免因为宕机丢失信息。</p>
<p>如果是单节点的Broker，需要配置Broker参数，将消息写入磁盘后再给Producer返回确认响应，由于此时消息已经写入磁盘了，服务恢复之后还能继续消费。</p>
<p>RocketMQ中，需要将刷盘方式flushDiskType配置为SYNC_FLUSH同步刷盘。</p>
<p>如果是多节点组成的Broker，需要配置Broker集群为：至少将消息发送到2个以上的节点，再给客户端回复发送确认响应，这样当Broker宕机时，其他的Broker也可以替代宕机的Broker，也不会发生消息丢失。</p>
</li>
<li>
<p>消费阶段和生产阶段一样，都是要根据请求确认机制，需要注意的是，不要再收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</p>
</li>
</ol>
<h2><a id="%E9%87%8D%E5%A4%8D%E6%B6%88%E6%81%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重复消息</h2>
<p>消息传递过程中，如果出现传递失败的情况，发送方会执行重试，重试的过程中就有可能会产生重复的消息。对使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。</p>
<p>在MQTT协议中，给出了三种传递消息时能够提供的服务质量标准，这三种服务指令从低到高依次是：</p>
<ul>
<li>At most once，至多一次，没有消息可靠性包之，允许丢消息，消息传递时，最多会被送达一次。</li>
<li>At least once，至少一次，不允许丢消息，但是允许有少量重复消息出现，消息传递时，至少会被送达一次。</li>
<li>Exactly once，恰好一次，消息传递时，只会被送达一次，不允许丢失也不允许重复，这个是最高标准。</li>
</ul>
<p>这个服务指令标准不仅适用于MTQQ，对所有消息队列都是适用的。</p>
<p>我们现在常用的绝大部分消息队列提供的服务质量都是At least once，包括RocketMQ/RabbitMQ/Kafka等，也就是说消息队列很难保证消息不重复。</p>
<p>解决重复消息问题的关键在于：<strong>幂等性</strong>（让消费消息的业务方法具有幂等性，也就是说其认一多次执行所产生的影响均与一次执行的影响相同）</p>
<p>如果我们系统消费消息的业务逻辑具备幂等性，那就不用担心消息重复的问题，从对系统影响结果来说，<strong>At least once + 幂等消费 = Exactly once</strong>。</p>
<p>常用的几种设计幂等操作的方法有：</p>
<ol>
<li>利用数据库的唯一约束实现幂等</li>
</ol>
<p>如果是关系型数据库，只要是支持类似” <strong>INSERT IF NOT EXIST</strong>“ 语义的存储系统都可以用于实现幂等，Redis的SETNX命令也可以替代数据库的唯一约束，来实现幂等消费。</p>
<ol start="2">
<li>为更新数据设置前置条件</li>
</ol>
<p><strong>给数据变更设置一个前置条件，如果满足条件就更新数据，否则拒绝更新数据。</strong></p>
<p>如果我们要更新的数据不是数值，是比较复杂的更新操作，<strong>更加通用的方法是给数据加一个版本号属性</strong>，每次更新数据之前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同事将版本号+1，一样可以实现幂等更新。</p>
<ol start="3">
<li>记录并检查操作</li>
</ol>
<p>适用范围最广的实现幂等性的方法：记录并检查操作，也成为”Token机制或者GUID（全局唯一ID）机制“。</p>
<p>具体实现方法是，在发送消息时，给每条消息指定一个全局唯一的ID，消费时先根据这个ID检查这条消息是否有被消费过，如果没被消费过，才更新数据，然后将消费状态设置为已消费。</p>
<p>然而，分布式系统中要实现”<strong>检查消费状态，然后更新数据并且设置消费状态</strong>“这三个操作作为一组操作保证<strong>原子性</strong>，才能实现幂等，否则就会出现Bug。</p>
<p>对于分布式系统，我们可以用事务，或者用锁来实现，但在分布式系统中，无论是分布式事务还是分布式锁都是比较难解决问题，所以一般不推荐使用。</p>
<p><strong>幂等性同样适用于其他重试导致的重复调用问题，可以举一反三。</strong></p>
<h2><a id="%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息积压</h2>
<p>消息积压得直接原因：系统中某个部分出现了性能问题，来不及处理上游发送的消息才会导致消息积压。</p>
<p>一般来说，我们解决消息积压问题时，关注点不应该是消息队列本身的性能（一般消息队列每秒钟能处理几万至几十万条消息的水平），主要关注点在于，我们的业务代码怎么和消息队列配合，达到一个最佳的性能。</p>
<ol>
<li>发送端性能优化</li>
</ol>
<p>一般发送端代码，都是先执行业务逻辑，最后才发送消息。如果说，发送端发送消息的性能上不去，需要有先检查一下，是不是<strong>发送消息之前的业务逻辑耗时太多导致</strong>。</p>
<p>一般来说，单线程的发送端<strong>发送消息的耗时</strong>包含的步骤主要是：1）发送端准备数据，序列化消息，构造请求等逻辑的时间，也就是发送端在发送网络请求之前的耗时；2）发送消息和返回想要在网络传输中的耗时；3）Broker处理消息的时延。</p>
<p>如果是单线程发送消息，每次只发送1条消息，相比于多线程，每次可以发送n条消息，再相比于多线程m批次发送消息，每次可以发送m*n条消息，所以只要业务逻辑能够适应多批量多线程的场景，<strong>设置合适的并发和批量大小，就可以达到很好的发送性能</strong>。</p>
<p>对于业务逻辑来说，</p>
<ol start="2">
<li>消费端性能优化</li>
</ol>
<h2><a id="%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%87%AA%E6%9F%A5q-a" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>消息队列自查Q&amp;A</h2>
<ul>
<li>消息队列常见用途？</li>
<li>使用消息队列有什么局限？</li>
<li>常见的消息队列产品有哪些？他们各有什么优缺点？</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K8s利用Nginx实现Ingress流量分发原理]]></title>
    <link href="chaoranlaoge.top/16454841763279.html"/>
    <updated>2022-02-22T06:56:16+08:00</updated>
    <id>chaoranlaoge.top/16454841763279.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kubectl 备考命令]]></title>
    <link href="chaoranlaoge.top/16442421379135.html"/>
    <updated>2022-02-07T21:55:37+08:00</updated>
    <id>chaoranlaoge.top/16442421379135.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%BA%94%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7">应试小技巧</a></li>
<li><a href="#kubectl-get">kubectl get</a>
<ul>
<li><a href="#kubectl-get%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0">kubectl get 额外参数</a></li>
</ul>
</li>
<li><a href="#kubectl-describe">kubectl describe</a></li>
<li><a href="#kubectl-run">kubectl run</a></li>
<li><a href="#kubectl-create">kubectl create</a></li>
<li><a href="#kubectl-scale">kubectl scale</a></li>
<li><a href="#kubectl-expose">kubectl expose</a></li>
<li><a href="#kubectl-label">kubectl label</a></li>
<li><a href="#kubectl-taint">kubectl taint</a></li>
</ul>

<h2><a id="%E5%BA%94%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应试小技巧</h2>
<p><code>export do=&quot;--dry-run=client -o yaml&quot;</code><br />
<code>kubectl run nginx --image=nginx $do &gt; pod.yaml</code></p>
<p><code>export now=&quot;--force --grace-priod 0&quot;</code><br />
<code>kubectl delete po nginx $now</code></p>
<h2><a id="kubectl-get" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl get</h2>
<p>kubectl 支持资源对象的简称：</p>
<table>
<thead>
<tr>
<th>资源对象</th>
<th>简称</th>
</tr>
</thead>
<tbody>
<tr>
<td>Configmaps</td>
<td>cfg</td>
</tr>
<tr>
<td>Pod</td>
<td>po</td>
</tr>
<tr>
<td>Service</td>
<td>svc</td>
</tr>
<tr>
<td>Deployment</td>
<td>deploy</td>
</tr>
<tr>
<td>ReplicaSet</td>
<td>rs</td>
</tr>
<tr>
<td>ReplicaController</td>
<td>rc</td>
</tr>
<tr>
<td>Namespace</td>
<td>ns</td>
</tr>
<tr>
<td>DaemonSets</td>
<td>ds</td>
</tr>
<tr>
<td>Nodes</td>
<td>no</td>
</tr>
<tr>
<td>ServiceAccounts</td>
<td>sa</td>
</tr>
<tr>
<td>Services</td>
<td>svc</td>
</tr>
<tr>
<td>PersistentVolumeClaims</td>
<td>pvc</td>
</tr>
<tr>
<td>PersistentVolume</td>
<td>pv</td>
</tr>
</tbody>
</table>
<h3><a id="kubectl-get%E9%A2%9D%E5%A4%96%E5%8F%82%E6%95%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl get 额外参数</h3>
<ul>
<li><code>-o yaml</code> 以yaml形式输出</li>
<li><code>-o wide</code> 输出更多信息</li>
<li><code>-l env=prod</code> 用以列出以标签env的值为prod的Pod</li>
</ul>
<h2><a id="kubectl-describe" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl describe</h2>
<ul>
<li>查看一个资源对象的详细信息</li>
</ul>
<blockquote>
<p>kubectl describe 简称 对象名称</p>
</blockquote>
<h2><a id="kubectl-run" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl run</h2>
<ul>
<li>创建一个po叫做nginx，包含一个容器，镜像是nginx</li>
</ul>
<blockquote>
<p>kubectl run nginx --image=nginx</p>
</blockquote>
<h2><a id="kubectl-create" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl create</h2>
<ul>
<li>创建一个deploy，名字是httpd，replicas=3，镜像名是httpd</li>
</ul>
<blockquote>
<p>kubectl create deploy httpd --replicas=3 --image=httpd</p>
</blockquote>
<h2><a id="kubectl-scale" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl scale</h2>
<ul>
<li>将Replica Set设置成replicas=5</li>
</ul>
<blockquote>
<p>kubectl scale --replicas=5 rs new-replica-set</p>
</blockquote>
<h2><a id="kubectl-expose" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl expose</h2>
<ul>
<li>将Deployment暴露为一个NodePort的Service，但需要注意的是，这个方法没办法指定NodePort端口，端口将为大于30000的随机端口，所以可以直接输出成文件之后再修改</li>
</ul>
<blockquote>
<p>kubectl expose deployment simple-webapp-deployment --port=8080 --target-port=8080 --type='NodePort' --selector='name=simple-webapp' --name webapp-service --dry-run=client -o yaml &gt; service.yaml</p>
</blockquote>
<h2><a id="kubectl-label" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl label</h2>
<h2><a id="kubectl-taint" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>kubectl taint</h2>
<ul>
<li>给Node1节点加上一个Taint信息</li>
</ul>
<blockquote>
<p>kubectl taint nodes</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM排查命令备忘录]]></title>
    <link href="chaoranlaoge.top/16425177538685.html"/>
    <updated>2022-01-18T22:55:53+08:00</updated>
    <id>chaoranlaoge.top/16425177538685.html</id>
    <content type="html"><![CDATA[
<h2><a id="jmap" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>jmap</h2>
<p><code>jmap -histo:live 进程号 &gt; 转存文件名称</code></p>
<p><code>jmap -histo:live</code> 会触发Full GC，<code>jmap -histo</code>不会触发</p>
<p><code>jmap -dump:live,format=b,file=文件名 进程号</code></p>
<h2><a id="jstat" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>jstat</h2>
<p><code>jstat -gcutil 进程号 1000 1000</code></p>
<h2><a id="mat%E5%B7%A5%E5%85%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MAT工具</h2>
<p>可以从<a href="https://www.eclipse.org/mat/previousReleases.php">MAT工具下载页面</a>直接下载MAT工具</p>
<p>MAT工具与JDK版本的关系是：<br />
1.8版本及以下MAT工具，对应的是JDK1.8及以下版本<br />
1.8版本及以上MAT工具，对应的是JDK1.9及以上版本</p>
<h2><a id="arthas" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Arthas</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL问题排查备忘录]]></title>
    <link href="chaoranlaoge.top/16419928857111.html"/>
    <updated>2022-01-12T21:08:05+08:00</updated>
    <id>chaoranlaoge.top/16419928857111.html</id>
    <content type="html"><![CDATA[
<p>MySQL，基于GPL开源协议，商标归属于Oracle，如果基于MySQL制作盈利软件，是需要购买Oracle的商业授权的，否则会违反GPL开源协议</p>
<p>MySQL，默认的事务隔离级别是可重复读，可以降低为？</p>
<h2><a id="%E5%87%A0%E4%B8%AA%E5%B8%B8%E7%94%A8%E7%9A%84sql%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>几个常用的SQL：</h2>
<p>select count(1) from xxx, 需要使用count(1), 不要使用count(*)，原因是？</p>
<p>date_format(time, '%Y%m%d%H%i%s'), 其中，%Y表示四位2022，%y是两位22，%H是24小时，%h是12小时，%i表示分钟</p>
<p>对于表里面的日期，Date类型的，可以直接 time = '20220101'</p>
<p>contains(str, sub_str) 报 Geometry byte string must be little endian 是因为 MySQL使用的是 instr(str, sub_str)，网上说 instr 比 like 更加高效，为啥？</p>
<p>insert into TABLE_NAME (PROPERTY_1, PROP_2, PROP_3) values (1, 2, 3)<br />
insert into TABLE_NAME select xx as PROP1, xx as PROP_2, xx as PROP_3 from TABLE where xxx</p>
<p>字符串匹配， str like / not like 'tmp%'</p>
<h2><a id="mysql%E7%9A%84%E6%AD%BB%E9%94%81%E6%8E%92%E6%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>MySQL的死锁排查</h2>
<p>使用语句： <code>show engine innodb status;</code></p>
<p>会有一段类似：</p>
<pre><code class="language-SQL">------------------------
LATEST DETECTED DEADLOCK
------------------------
191028 13:33:14
*** (1) TRANSACTION:
TRANSACTION 2656E7, ACTIVE 1 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 376, 1 row lock(s)
MySQL thread id 879805, OS thread handle 0x7f8d26308700, query id 3761780 XXXXXXXXXXXXX root Updating
update student SET school = &quot;清华&quot; WHERE ( name = '小明' )
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 0 page no 1362 n bits 376 index `name_age` of table `数据库1`.`student` trx id 2656E7 lock_mode X waiting
XXXXXX

*** (2) TRANSACTION:
TRANSACTION 2656E2, ACTIVE 1 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1248, 2 row lock(s), undo log entries 3
MySQL thread id 879796, OS thread handle 0x7f8d261c3700, query id 3761781 XXXXXXXXXXXXX root update
insert into student (XXXXXXXXXXXXXXXXXXXXXXXX)
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 0 page no 1362 n bits 376 index `name_age` of table `数据库1`.`student` trx id 2656E2 lock_mode X locks rec but not gap
XXXXXX

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 0 page no 1362 n bits 376 index `name_age` of table `数据库1`.`student` trx id 2656E2 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 292 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
XXXXXX

*** WE ROLL BACK TRANSACTION (1)
------------

</code></pre>
<p>然后MySQL的锁机制是分引擎的，innodb和其他不一样，在查锁之前，要先搞清楚他本身的引擎类型</p>
<p>如果是innodb，锁也是挺多种的，IX，意向写锁，IS，意向读锁，X写锁，S读锁，Gap是间隙锁，Next-Key是键值锁？</p>
<p>MySQL有两种死锁，一种是他自检测到死锁，会自己解除。另一种是两者互相等待，会等到一个获取锁的超时时长，环境上有时候会配置600（10分钟）？</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[家居装修笔记]]></title>
    <link href="chaoranlaoge.top/16374690084475.html"/>
    <updated>2021-11-21T12:30:08+08:00</updated>
    <id>chaoranlaoge.top/16374690084475.html</id>
    <content type="html"><![CDATA[
<ul>
<li><a href="#%E5%AE%9E%E6%9C%A8%E5%BA%8A">实木床</a></li>
<li><a href="#%E5%A2%99%E9%9D%A2%E6%9D%90%E6%96%99">墙面材料</a></li>
<li><a href="#%E5%AE%9A%E5%88%B6%E6%9F%9C%E6%9D%BF%E6%9D%90">定制柜板材</a>
<ul>
<li><a href="#%E6%9F%9C%E9%97%A8%E6%80%BB%E7%BB%93">柜门总结</a></li>
<li><a href="#%E6%9D%BF%E6%9D%90%E6%80%BB%E7%BB%93">板材总结</a></li>
<li><a href="#%E7%9C%9F%E4%BC%AA%E9%89%B4%E5%AE%9A">真伪鉴定</a></li>
</ul>
</li>
<li><a href="#%E5%B0%81%E7%AA%97">封窗</a>
<ul>
<li><a href="#%E7%AA%97%E6%88%B7%E9%87%87%E8%B4%AD">窗户采购</a>
<ul>
<li><a href="#%E9%97%A8%E7%AA%97%E7%A7%8D%E7%B1%BB">门窗种类</a></li>
<li><a href="#%E9%93%9D%E6%9D%90">铝材</a></li>
<li><a href="#%E9%93%9D%E6%9D%90%E5%93%81%E7%89%8C">铝材品牌</a></li>
<li><a href="#%E7%AA%97%E5%AE%BD">窗宽</a></li>
<li><a href="#%E7%AA%97%E5%A3%81%E5%8E%9A">窗壁厚</a></li>
<li><a href="#%E9%9A%94%E7%83%AD%E6%9D%A1">隔热条</a></li>
<li><a href="#%E5%BC%80%E5%90%88%E8%83%B6%E6%9D%A1">开合胶条</a></li>
<li><a href="#%E7%AA%97%E6%88%B7%E7%8E%BB%E7%92%83">窗户玻璃</a></li>
<li><a href="#%E7%AA%97%E6%88%B7%E4%BA%94%E9%87%91">窗户五金</a></li>
<li><a href="#%E7%AA%97%E6%88%B7%E7%BA%B1%E7%AA%97">窗户纱窗</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<h2><a id="%E5%AE%9E%E6%9C%A8%E5%BA%8A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实木床</h2>
<p>3k-6k 小半龙猫床 二黑木作保龄床</p>
<p>6k-8k，MUU HOME和凡屋</p>
<p>要着重看龙骨骨架间隙，不要大于5cm</p>
<p>可以找沙发或者窗帘定制一个床头软包枕头，可拆卸</p>
<h2><a id="%E5%A2%99%E9%9D%A2%E6%9D%90%E6%96%99" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>墙面材料</h2>
<p>全屋建议：乳胶漆 &gt; 艺术漆 &gt; 墙布</p>
<p>局部提高视觉：护墙板 &gt; 艺术漆/墙布</p>
<p>护墙板 优点是隔音隔热 近期流行木饰面<br />
木饰面有分两种：成品定制版和正规渠道的科定板，不要选竹木纤维板，要注意安装收口细节是否处理到位</p>
<p>打算：电视背景墙和卧室背景墙，做局部视觉装饰</p>
<h2><a id="%E5%AE%9A%E5%88%B6%E6%9F%9C%E6%9D%BF%E6%9D%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定制柜板材</h2>
<h3><a id="%E6%9F%9C%E9%97%A8%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>柜门总结</h3>
<p><img src="media/16374690084475/16374741182561.jpg" alt="" /></p>
<h3><a id="%E6%9D%BF%E6%9D%90%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>板材总结</h3>
<p>建议柜体选择多层实木板，柜门选择高密度板，或者质地紧实的颗粒板，总结如下：</p>
<p><img src="media/16374690084475/16374738823699.jpg" alt="" /></p>
<h3><a id="%E7%9C%9F%E4%BC%AA%E9%89%B4%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>真伪鉴定</h3>
<ul>
<li>查看板材检测报告</li>
<li>定准下面两个标识：<br />
<img src="media/16374690084475/16374695206089.jpg" alt="" /></li>
<li>看是否是国家级人造板检验中心</li>
<li>报告内页的检验依据和检验项目里，甲醛释放量<br />
<img src="media/16374690084475/16374696490936.jpg" alt="" /><br />
甲醛释放量要小于等于0.124</li>
<li>看商标栏填写的是否是你买的板材品牌名，可以扫描二维码</li>
<li>荧光灯可以照射出板材上的logo</li>
<li>进口品牌可以打公众号的联系电话，看授权点卖的是不是经销商进口的</li>
</ul>
<h2><a id="%E5%B0%81%E7%AA%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>封窗</h2>
<h3><a id="%E7%AA%97%E6%88%B7%E9%87%87%E8%B4%AD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>窗户采购</h3>
<p>优秀的系统门窗品牌有，旭格，贝洛克，墨瑟</p>
<h4><a id="%E9%97%A8%E7%AA%97%E7%A7%8D%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>门窗种类</h4>
<p>不推荐塑钢和铝合金<br />
不推荐购买推拉窗，密封性和气密性差<br />
普通断桥铝和系统门窗，就相当于组装台式机和品牌台式机的区别</p>
<h4><a id="%E9%93%9D%E6%9D%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>铝材</h4>
<p>铝材，有铝材检测报告，报告上的规格需要是：<br />
<img src="media/16374690084475/16374699740228.jpg" alt="" /></p>
<h4><a id="%E9%93%9D%E6%9D%90%E5%93%81%E7%89%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>铝材品牌</h4>
<p>知名铝材品牌如下：<br />
<img src="media/16374690084475/16374700029589.jpg" alt="" /></p>
<p>预算充足情况下，选择氟碳喷涂的铝材，表面平整度搞，手感很亲肤细腻</p>
<h4><a id="%E7%AA%97%E5%AE%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>窗宽</h4>
<p>窗宽宽度，一般有65，70, 75, 85, 90, 120，具体是指<br />
<img src="media/16374690084475/16374701685323.jpg" alt="" /></p>
<p>窄的地方的宽度，窗宽不要选择75以下的</p>
<h4><a id="%E7%AA%97%E5%A3%81%E5%8E%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>窗壁厚</h4>
<p><img src="media/16374690084475/16374703521789.jpg" alt="" /></p>
<p>壁厚至少要1.8mm起，壁厚要均匀</p>
<h4><a id="%E9%9A%94%E7%83%AD%E6%9D%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>隔热条</h4>
<p>选择PA66 gf25，具体图片如下：<br />
<img src="media/16374690084475/16374704318421.jpg" alt="" /></p>
<p>点火不会燃烧</p>
<p>隔热胶条一般是随着窗宽越宽越好，75系列的要做到4cm左右</p>
<p>要选择航架的隔热胶条，隔热性会更好</p>
<p><img src="media/16374690084475/16374705408460.jpg" alt="" /></p>
<p>专业隔热条品牌，泰诺风</p>
<p>隔音隔热要更好，中间要防止聚氨酯发泡填充，保温棉效果会差很多</p>
<h4><a id="%E5%BC%80%E5%90%88%E8%83%B6%E6%9D%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>开合胶条</h4>
<p>选三元乙丙橡胶条，常用品牌是江阴海达</p>
<h4><a id="%E7%AA%97%E6%88%B7%E7%8E%BB%E7%92%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>窗户玻璃</h4>
<p><img src="media/16374690084475/16374719109919.jpg" alt="" /></p>
<p>窗户要做一体弯工艺，比较美观</p>
<p>黑色的丁基胶，第一道密封胶</p>
<p>灰色的密封胶，外层密封胶应该使用中性胶，酸性的会和丁基胶发生反应，会渗油或水</p>
<p>玻璃中间是惰性空气层，一般是打满90%的氩气</p>
<p>横剖面如下：<br />
<img src="media/16374690084475/16374720245600.jpg" alt="" /></p>
<p>干燥剂要选择优质的分子筛</p>
<p>玻璃要选择更好的low-e镀膜，隔热性更强，其他膜会影响采光</p>
<p>中空玻璃间隙在9-27mm，建议选择12-15mm</p>
<p>我要选择三波两腔的，图如下：</p>
<p><img src="media/16374690084475/16374722375943.jpg" alt="" /></p>
<p>隔音效果好的，要选中空夹胶玻璃，优质的玻璃品牌有如下图：</p>
<p><img src="media/16374690084475/16374722848045.jpg" alt="" /></p>
<h4><a id="%E7%AA%97%E6%88%B7%E4%BA%94%E9%87%91" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>窗户五金</h4>
<p>好评度高的品牌如下：<br />
<img src="media/16374690084475/16374732058406.jpg" alt="" /></p>
<p>五金都是一套一套卖的，不存在单个零件多品牌的问题</p>
<h4><a id="%E7%AA%97%E6%88%B7%E7%BA%B1%E7%AA%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>窗户纱窗</h4>
<p>现在流行高透网，材质如下图：</p>
<p><img src="media/16374690084475/16374733534189.jpg" alt="" /></p>
<p>纱窗一定要做那种，可以轻松拆卸的</p>
<p>比较推荐铝合金高透和进口的PET高透</p>
<p>一般来说高透是20目，也有高级一点的48目</p>
<ol>
<li>纱网光滑有质感</li>
<li>纱网装窗工艺，不会鼓包和保持平整</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第三部分摘录]]></title>
    <link href="chaoranlaoge.top/16374149083076.html"/>
    <updated>2021-11-20T21:28:28+08:00</updated>
    <id>chaoranlaoge.top/16374149083076.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%81%93%E5%BE%B7%E8%B0%B4%E8%B4%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>道德谴责</h2>
<blockquote>
<p><strong>道德判断, 永远要先己后人</strong>。<br />
爱因斯坦说: “真正的问题在于人的心灵与思想……让我们害怕的, 不是原子弹的爆炸力量, 而是人心的邪恶力量。”<br />
我们每一个人都是问题的一部分。<br />
安徒生有一个非常著名的成人童话, 叫作 <strong>《影子》</strong> 。故事的梗概是: 一个作家总是好奇对面阳台的人家, 越是看不到, 作家越是想偷窥。有一天, 作家的影子轻易投射到对面阳台, 影子看到了别人家的一切。后来作家醒来, 影子不见了。因为影子长大了, 离他而去。再后来影子回来了, 杀死了主人, 将主人取而代之。<br />
我们每一个人都有一个黑暗的影子, 如果我们任由它长大, 有一天它会吞噬我们。<br />
如果总是盯着他人的黑暗, 而无视自己内心的幽暗, 总有一天, 你的影子会吞掉你。<br />
不要对人性抱以过高的期待, <strong>永远要警惕人性深处的幽暗</strong>。法治的前提就是对人性败坏的假设, <strong>所以任何人组成的权力机构都要受到法律严格的约束, 权力从来就不应被完全信任</strong>。<br />
如果抛弃了这个假设, 认为人性良善, 法治也一定会为人治所取代, 对人性美好的假设往往都带来了空前的灾难。<br />
因此, 这也是为什么<strong>绝大多数国家都很少在法律中规定单纯的“见危不救罪”, 法律只是对公民最低的道德要求</strong>。<br />
刘某的懦弱令人遗憾, 值得谴责。<br />
<strong>勇敢是一种高贵的品质, 但是不勇敢却没有必要如此口诛笔伐</strong>, 千夫所指, 甚至以犯罪论处。</p>
</blockquote>
<p>法律只是对公民最低的道德要求。</p>
<blockquote>
<p>每个人的心中都有一个“理想人”的范例, 用柏拉图的术语来说这叫作<strong>人的“共相”</strong>。这种“理想人”有着高尚、勇敢、知恩图报等诸多美德。<br />
当他人的行为举止严重违反了“理想人”的标准, 就会激起我们内心的愤怒。这种愤怒本身是正常的。<br />
虽然有很多人说人的“共相” (“理想人”范例) 并不存在, 它只是一种假设, 但<strong>我更愿意相信“共相”不是假设, 而是一种客观实在</strong>。正如人类无论用任何仪器都无法画出一个完美的圆, 但“圆”这个概念是客观存在的。<br />
<strong>正是这种“理想人”的范例激起我们的道德意识, 也让我们一生可以不断行走在德行之路, 高山仰止, 虽不能至,心向往之</strong>。</p>
</blockquote>
<p>理想人，高山仰止。</p>
<blockquote>
<p>人为什么会进行道德谴责呢？动机多种多样，我想至少有如下理由：</p>
<ol>
<li>我们心中“理想人”范例的召唤。</li>
<li>希望他人改过自新。</li>
<li>自以为是, 表达道德优越。</li>
<li>还有其他许多动机, 如博人眼球、营销造势、消费他人的痛苦等。</li>
</ol>
</blockquote>
<p>道德谴责，不管是冷热，都是由自己针对他人，那目的主要还是希望他人改过自新，其意义最大，而其他动机则表现为对自身的增益，可有可无。</p>
<blockquote>
<p><strong>西汉文帝之所以废除肉刑, 就是因为肉刑断人肢体, 毁人容貌, 是对人格的侮辱, 也彻底断绝了罪犯改过自新的可能。</strong> 所以当<strong>缇萦救父</strong>, 上书文帝, 缇萦短短数语, 戳中文帝泪点——“妾父为吏, 齐中称其廉平, 今坐法当刑, 妾切痛死者不可复生, 而刑者不可复续, <strong>虽欲改过自新, 其路莫由</strong>。妾愿入身为官婢, 以赎父刑罪, 使得改行自新也。” (我的父亲做官吏, 齐地的人都说他清廉公平, 如今犯法应当获罪受刑。我为受刑而死的人不能复生感到悲痛,而受过刑的人不能再长出新的肢体, 即使想改过自新, 也没办法了。我愿意舍身做官府中的女仆来赎父亲的罪过, 让他能改过自新” ) 文帝后在废肉刑的诏书中直接援引少女缇萦之语——“虽欲改过自新, 其路莫由也。”</p>
</blockquote>
<blockquote>
<p>因此, 所有的道德谴责都不应该随意侮辱他人的人格,诸如“人渣”“狗男女” “禽兽”这种情绪化的表达在<strong>亵渎他人的同时也侮辱了自己</strong>。同时, 将他人在道德上彻底“批臭批死”也从此堵住了他人改过自新的可能。</p>
</blockquote>
<p>留他人一条后路，给他人改过自新的机会。否则，不如以此为鉴，沉默自省。</p>
<blockquote>
<p><strong>道德与法律不同, 它主要是一种自律。</strong> 因此, 在开启道德谴责的阀门时, 一定也要进行自我的反省, 这样才能让本能的愤怒在正确的渠道中运行并产生积极的作用, 而不至于像洪水一般, 泛滥成灾。<br />
老实说, 对于江歌案, 任何人都会感到愤怒, 人不能做到“太上而忘情”。但是, 当我陷入愤怒时, 心中的“理想人”告诉我要勇敢、要感恩、要知耻之时, 我首先把这种声音作为是对我自己的提醒。<br />
当我批评他人懦弱的时候, 我真的希望自己能够勇敢一点, 我心中的“理想人”告诉我,<strong>“你真的不够勇敢。当你批评某个热点案件的当事人时, 除了加入集体情绪狂欢以外, 你还做了什么? 你敢不敢付出代价走出书斋,去帮助弱者, 去对抗不公, 去匡扶正义, 与悲伤的人一路同行?”</strong></p>
</blockquote>
<p>道德谴责终究停留在口头，要真正的走在对抗不公，匡扶正义的路上。</p>
<h2><a id="%E8%BE%A9%E6%8A%A4%E5%88%B6%E5%BA%A6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>辩护制度</h2>
<p>刑事辩护，“为罪行重大之人辩护，正是为了防止无辜之人枉受追究”。</p>
<blockquote>
<p>今人多将刑事辩护追溯至古希腊, 却忘记了西方文明的另一重要源头——“希伯来—基督教信仰”。成书约公元前15世纪的《摩西五经》之一的《创世记》就有关于辩护的内容, 这远早于公元前8世纪才出现的古希腊文明。<br />
《创世记》第十八章17—33节中, 当上帝欲毁灭所多玛和蛾摩拉两城时, 亚伯拉罕站了出来, 为这两城辩护。<br />
亚伯拉罕近前来, 说: “无论善恶, 你都要剿灭吗? 假若那城里有五十个义人, 你还剿灭那地方吗? 不为城里这五十个义人饶恕其中的人吗? 将义人与恶人同杀, 将义人与恶人一样看待, 这断不是你所行的。审判全地的主岂不行公义吗?”耶和华说: “我若在所多玛城里见有五十个义人, 我就为他们的缘故饶恕那地方的众人。”亚伯拉罕说: “我虽然是灰尘, 还敢对主说话。假若这五十个义人短了五个, 你就因为短了五个毁灭全城吗?”他说: “我在那里若见有四十五个, 也不毁灭那城。”亚伯拉罕又对他说: “假若在那里见有四十个怎么样呢?”他说: “为这四十个的缘故, 我也不做这事。”亚伯拉罕说, 求主不要动怒, 容我说: “假若在那里见有三十个怎么样呢?”他说: “我在那里若见有三十个, 我也不作这事。”亚伯拉罕说:“我还敢对主说话, 假若在那里见有二十个怎么样呢?”他说: “为这二十个的缘故, 我也不毁灭那城。”亚伯拉罕说:“求主不要动怒, 我再说这一次, 假若在那里见有十个呢?”他说: “为这十个的缘故, 我也不毁灭那城。”耶和华与亚伯拉罕说完了话就走了; 亚伯拉罕也回到自己的地方去了。<br />
《创世记》中的上帝通过欲毁灭罪城的案例, 生动形象地教导了亚伯拉罕何谓人类的公平正义以及如何对待有罪之人, 这奠定了刑事辩护制度的基本原则。上帝能够区分出有罪与无辜, 但人类则未必, 上帝用这个案例让亚伯拉罕思考, 人类如何建立一套制度来区分有罪与无辜。在这个上帝与人类交互式学习的案例中, 亚伯拉罕因为五十义人而质疑上帝毁城的决定, 上帝也乐意与他讨论, 最后亚伯拉罕以十个义人收尾。<br />
上帝在教导亚伯拉罕, 人类的司法制度必然存在缺陷,最坏的制度是宁可错杀千人也不放过一人, 但为了不枉杀一人, 就放过千万个有罪之人, 也不太合适, 因此必须寻求一个平衡点。上帝同意亚伯拉罕的观点, 只要有足够的好人,就应该把整个团体, 包括其中的坏人一并饶过。但<strong>同时告诉亚伯拉罕如何在错杀与枉纵之间取得平衡, 所以最后亚伯拉罕到十人为止</strong>。<br />
这个故事对于刑事辩护制度至关重要。上帝通过“案例教学”, 让亚伯拉罕学到了一堂生动的辩护课程。这个故事告诉我们, 辩护首先是防止冤枉无辜, 人类无法轻易区分谁有罪谁无罪, <strong>如果只有明显无辜的人才能得到刑事辩护, 那么必将有大量无辜的人受冤枉。所多玛和蛾摩拉罪恶滔天,但仍应为其辩护, 为罪行重大之人辩护, 正是为了防止无辜之人枉受追究。</strong>[2]<br />
其次,《创世记》中的上帝乐于亚伯拉罕向他挑战, 这正是告诉亚伯拉罕, 默许冤屈就是罪恶, 世俗社会的任何权威都应该接受质疑, 连上帝都可以接受亚伯拉罕的质询,更何况由理性有限的人类所组成的政府机构。即便是最好的人类道德和司法制度, 也是有可能误杀无辜的。所以,<strong>司法机关必须虚心接受律师的诘问质疑, 否则必然导致司法擅权专断, 腐败无能</strong>。<br />
最后, 《创世记》中的上帝让亚伯拉罕知道, 世俗社会的公平正义就是寻找合适的<strong>平衡点</strong>, 辩护制度也不例外。</p>
</blockquote>
<p>古希腊的人本主义传统会导致，律师以辩护人利益最大化为目的，而曲意逢迎，无主见且狡黠。柏拉图甚至直言“律师总是忙忙碌碌,似乎总有什么力量不断驱赶着他……他是一个奴隶。在他的主人面前, 与他同是奴隶的伙伴们争论不休”。</p>
<blockquote>
<p>“希伯来—基督教”信仰强调神本主义, 一神论的信仰确认了绝对真理的客观存在, 上帝之道即为真理, 所谓“太初有道, 道与上帝同在, 道就是上帝”。因此, **辩护制度应当接受绝对真理的约束, 辩护必须在规则范围内行使。**按照这种信仰观, 辩护人在辩护时要受到限制, <strong>十诫中第九诫“不可作假见证陷害人”当为辩护人之铁律</strong>; 同时人权也须受到限制, 正如亚伯拉罕在为罪城辩护的案例中所学习到的, <strong>保障人权不能以完全牺牲惩罚犯罪为代价</strong>。</p>
</blockquote>
<p>“辩护制度应当接受绝对真理的约束, 辩护必须在规则范围内行使”</p>
<p>律师制度的定位：</p>
<ol>
<li>律师必须在法律范围内维护当事人的合法权益</li>
<li>刑法应在惩罚犯罪与保障人权这两个价值之中寻找平衡</li>
</ol>
<blockquote>
<p>哈佛大学教授德肖维茨说: “一个国家是否有真正的自由, 试金石之一是它对那些为有罪之人、为世人不耻之徒辩护的人的<strong>态度</strong>。在大部分专制国家里, 独立自主的辩护律师队伍是不存在的。诚然, <strong>专制压迫肆虐无忌</strong>的明显标志之一就是<strong>政府开始迫害辩护律师</strong>。”</p>
</blockquote>
<h2><a id="%E5%BC%82%E6%97%8F%E4%BB%87%E6%81%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>异族仇恨</h2>
<blockquote>
<p>人类历史上, 几乎所有的<strong>暴政最初都是利用民众对外族的仇恨</strong>, 如当初希特勒上台时鼓动德国人对法国的仇恨。<br />
当仇恨在心中发芽、长大, 人也就慢慢忘记了最宝贵的东西是<strong>他的内在尊严</strong>, 而不在于外在的身份。<br />
仇恨, 总有一天会让人把枪口调转, 从对外变成对内,进而对着自己的亲朋好友。<br />
当人的心为仇恨所奴役, 他的肉体也必然 <strong>被外在的强权所奴役</strong>。</p>
</blockquote>
<blockquote>
<p>在美国拉斯维加斯枪击案这样一个特殊的时候, 愿你我感同身受, 让我们再次重温<strong>约翰·多恩古旧的布道辞“不要问丧钟为谁而鸣”</strong>:<br />
“没有人是自成一体、与世隔绝的孤岛, 每一个人都是广袤大陆的一部分。如果海浪冲掉了一块岩石, 欧洲就减少。如同一个海岬失掉一角, 如同你的朋友或者你自己的领地失掉一块。每个人的死亡都是我的哀伤, 因为我是人类的一员。所以, 不要问丧钟为谁而鸣, 它就为你而鸣!”<br />
爱, 是永不止息。</p>
</blockquote>
<h2><a id="%E5%8E%9F%E8%B0%85" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>原谅</h2>
<p>既然我们每天都在原谅一个不那么可爱的自己, 那么当别人做错事的时候, 当别人冒犯你时, 你是不是也能够<strong>爱人如己, 推己及人</strong>呢?</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[人生一串 第三季]]></title>
    <link href="chaoranlaoge.top/16374121683009.html"/>
    <updated>2021-11-20T20:42:48+08:00</updated>
    <id>chaoranlaoge.top/16374121683009.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E7%AC%AC%E4%B8%80%E9%9B%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第一集</h2>
<p>山东-临淄 葱+小饼+烤肉 烤梅花猪肉，加花生碎 芽葱 高丽烧烤</p>
<p>延边黄牛 每10头只有一头有雪中玫瑰的惊艳花色 雪花肉</p>
<p>吉林大兴沟 牛小肝 独有湿料 老宋烧烤</p>
<p>中山小榄镇 盒装内裤生产份额占3成 脆肉皖（草鱼鱼腩） 淡水黄油 大师兄烧烤</p>
<p>云南西双版纳勐海县 老街 傣族烧烤 蘸水（柠檬蘸水沾鱼，干料沾肉，腐乳蘸料）， 百旺（碎肉+鲜猪血） 百旺烧烤</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识数据库连接池到读懂HikariCP源码]]></title>
    <link href="chaoranlaoge.top/16361613816170.html"/>
    <updated>2021-11-06T09:16:21+08:00</updated>
    <id>chaoranlaoge.top/16361613816170.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16361613816170/16361616058541.jpg" alt="HikariCP" /></p>
<p>HikariCP，第二代数据库连接池产品，代码非常精简高效，是一个值得深度源码的项目。本文从数据库连接池这个小众领域介绍开始，慢慢梳理HikariCP的源码。</p>
<p><img src="media/16361613816170/16361616887609.jpg" alt="github-page" /></p>
<span id="more"></span><!-- more -->
<h2><a id="%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%8E%9F%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据库连接池原理</h2>
<ul>
<li>什么是数据库连接池？</li>
</ul>
<blockquote>
<p>在软件工程中，连接池（英语：connection pool）是维护的数据库连接的缓存，以便在将来需要对数据库发出请求时可以重用连接。--- Wikipedia</p>
</blockquote>
<p>数据库连接池，本质上是缓存，存储可复用的数据库连接。所谓的数据库连接，具体指的是物理网络的TCP/IP连接，程序中会被抽象为程序对象。</p>
<blockquote>
<p>数据库连接(database connection)是数据库服务器与客户端之间的通信联系。客户通过数据库连接发送命令、接收服务器返回的结果。 -- Wikipedia</p>
</blockquote>
<p>基本上所有主流的数据库，都使用连接池技术来改善性能。建立连接时，通常需要提供一个驱动程序和一个连接字符串（eg. jdbc-url)</p>
<ul>
<li>市面上的数据库连接池有几种？</li>
</ul>
<p>市面上的数据库连接池产品有两代，区分的特征是看他在架构和设计时采用的线程模型，一般来说是两种线程模型，单线程模型和多线程模型。</p>
<p>第一代产品包括：DBCP，C3P0，Tomcat-jdbc<br />
第二代产品包括：Druid，HikariCP</p>
<ul>
<li>为什么要使用数据库连接池？</li>
</ul>
<blockquote>
<p>连接池用于提高在数据库上执行命令的性能。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序发出的请求，既昂贵又浪费资源。 -- Wikipedia</p>
</blockquote>
<ul>
<li>
<p>连接池是怎么实现？</p>
</li>
<li>
<p>HikariCP和Druid怎么使用？</p>
</li>
<li>
<p>连接池产品如何选型？</p>
</li>
</ul>
<h2><a id="hikaricp%E4%BA%A7%E5%93%81%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>HikariCP产品介绍</h2>
<ul>
<li>
<p>HikariCP的性能如何？</p>
</li>
<li>
<p>HikariCP的性能突破来源于什么？</p>
</li>
<li></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[小王子，他学会的爱与被爱]]></title>
    <link href="chaoranlaoge.top/16335352502635.html"/>
    <updated>2021-10-06T23:47:30+08:00</updated>
    <id>chaoranlaoge.top/16335352502635.html</id>
    <content type="html"><![CDATA[
<h2><a id="%E9%87%8D%E6%B8%A9%E3%80%8A%E5%B0%8F%E7%8E%8B%E5%AD%90%E3%80%8B%E7%9A%84%E6%80%9D%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>重温《小王子》的思考</h2>
<p>小王子，这本书所获盛誉，不再赘述。给我重温动力的动机，其实还满值得一讲的。</p>
<p>当时我记得是七夕前，罗翔老师在B站开了一个直播（我看的是回播）。直播里面主体意思是推荐同学们重读或者去读《小王子》，为什么呢？大体的理由是，我们要保留人性中纯真的一面，要学会爱他人，和被爱。最后罗翔老师用这本书摩挲鼻头，被许多网友吐槽“老师你怎么拿这本书来擦鼻子”让我又笑着退出了这个视频。虽然我是看过《小王子》的，而且当初读的时候也有所收获，但我并没读出里面有教人爱这一层意思。那时退出视频，我心里带着疑惑，也留下了一个种子。</p>
<span id="more"></span><!-- more -->
<p>时光飞逝，到了国庆这几天，实在没事干，我就重温了这本书，《小王子》这本书的内容着实不多，从头到尾，每一章简单的故事背后其实都有涵盖的哲学意义，很多时候读起来就像是在打哑谜（多多少少影射了社会的一些现实，有些讽刺，也有些惋惜，这里不做过多解释）。</p>
<p>而我此行，主要是为了读懂其中的爱与被爱，全书下来，就剩下3个重要人物于此相关，玫瑰，小王子和狐狸。</p>
<p>所以我这里摘录4个场景，分别是，小王子日常照顾玫瑰，小王子与玫瑰告别，狐狸请求小王子驯服她，小王子与狐狸告别，来谈谈我的理解。</p>
<h3><a id="%E5%B0%8F%E7%8E%8B%E5%AD%90%E6%97%A5%E5%B8%B8%E7%85%A7%E9%A1%BE%E7%8E%AB%E7%91%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小王子日常照顾玫瑰</h3>
<blockquote>
<p>就这样，这朵敏感而虚荣的花儿开始折磨小王子。比如说有一天，正好聊到她的四根刺，她对小王子说：<br />
“老虎要来就让它来，我可不怕它的利爪！”<br />
“我的星球上没有老虎，”小王子，“再说老虎也不吃草。”<br />
“人家又不是草，”这朵花娇滴滴地说。<br />
“对不起……”<br />
“反正我不怕老虎，但我讨厌风。你就没有挡风的隔板吗？”<br />
“居然怕风……这对植物来说太不幸了，”小王子心里想，“这朵花的心事真是难懂呀。”<br />
“到了傍晚你要把我放在玻璃罩里。你这里太冷啦。我住着很不方便耶。在我家乡那边……”<br />
说到这里她就停了。她是由一颗种子发育而成的。她并不熟悉别的地方。这么天真的谎言差点被当场揭穿，她感到有点惭愧，于是假咳了两三声，责怪起小王子来：<br />
“挡风的隔板呢？”<br />
“我本来想去拿的，但你要跟我说话啊！”<br />
她又假咳了几声，就是想让小王子感到自责。<br />
所以小王子虽然很愿意去爱护她，但也很快产生了怀疑。小王子总是把她的话当真，但很多话她其实只是随口说说而已，这让小王子很不高兴。</p>
</blockquote>
<p>不知道读者看到这里和我有没有同感，<br />
“玫瑰，像不像情侣关系里面，比较作的那个人？”<br />
玫瑰她的需求，其实是需要额外的呵护，但小王子很直男，更多的是只把她的话当真了，然后想理解这朵玫瑰真实的想法。</p>
<p>但是，很多时候玫瑰说话，都只是随口说说而已，小王子被绕来绕去，觉得这朵玫瑰很不真诚，这些话也让他不高兴。玫瑰的话，甚至有的太天真了差点被当成揭穿，她也觉得有点惭愧。</p>
<p>其实就语言交流这一方面来说，小王子和玫瑰的交流模式并不融洽，一个会不高兴，另一个会惭愧，没有人开心，这一点后面狐狸其实是明白为什么的（因为语言，具有误导性）。其实人与人之间的交流，也很容易遇到这个情况，要打破这一点，不需要说太多其实，主要是要真诚。</p>
<p>不过，就日常来看，小王子照顾玫瑰，玫瑰释放花香给小王子，场面都很和谐。就行为模式上来说，他们俩相处的很融洽，就行为上来看，其实他们是相爱的。</p>
<p>对于这一部分，我理解到的是，所谓爱，不是一句话，是行动。语言有误导性，但行动是真实的。要明白小把戏，需要经验，新手不太行哈哈哈。</p>
<h3><a id="%E5%B0%8F%E7%8E%8B%E5%AD%90%E5%91%8A%E5%88%AB%E7%8E%AB%E7%91%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小王子告别玫瑰</h3>
<blockquote>
<p>“再见，”他对花儿说。<br />
但她没有回答。<br />
“再见，”他又说。<br />
花儿咳嗽了。但这不是因为她着了凉。<br />
“我以前很笨，”她终于开口了，“对不起。祝你幸福。”<br />
他很惊讶花儿居然没有责怪他。他愣住了，玻璃罩也停在半空。他无法理解这种平静的甜蜜。<br />
“是的，我是爱你的，”花儿说，“你却什么都不知道，这是我的错。没关系。但你和我一样笨。祝你幸福……把玻璃罩拿走吧，我再也不想要它了。”<br />
“可是会有风的啊……”<br />
“我的感冒没那么严重……夜里凉爽的空气对我有好处。我可是花耶。”<br />
“可是会有昆虫和野兽的……”<br />
“我愿意忍受两三条毛毛虫的，因为我想认识蝴蝶。听说蝴蝶很漂亮。否则谁来探望我呢？你就要去远方啦。至于大动物，我可不怕，我有爪子的。”<br />
她天真地露出了那四根刺。接着她又说：<br />
“别磨蹭了，这让我很难受的。既然你决定要离开，那就走吧。”<br />
因为她不希望让小王子看到她流泪。这朵花还真是骄傲啊…</p>
</blockquote>
<p>这段话，如果把小王子和玫瑰换成偶像剧里要分手的男主女主名字，然后文字意思稍微生活化一些，一点违和感都不会有。</p>
<p>玫瑰她承认自己是爱小王子的，“你却什么都不知道，这是我的错。没关系。但你和我一样笨”这句话，我读了很多遍，不太好理解。</p>
<p>现在我的理解是，玫瑰没把爱小王子这件事情说出来让他知道，而是说那些旁敲侧击的话，想让小王子更加呵护她爱她，其实她做到了，但她也发现了小王子其实没懂，小王子只是按她说的做了，不会先她一步想到要做这些，她觉得小王子很笨。</p>
<p>当小王子没有留恋，想走了，她才发现其实自己没有真正做到，发现自己也很笨。所以她说，“你和我一样笨”。这个缘分没有走到底，她承认，错在于她，因为她没让小王子真的明白，自己其实深爱着他。</p>
<p>小王子在这个场景里，作者说他无法理解这种平静的甜蜜，他两次说了“可是”，最后他还是走了。书本描述至此，小王子其实还不懂的什么是被爱，书的内容太少了，其实我也没看出来。但我觉得，他已经学会怎么爱这朵玫瑰了，他会主动给她盖玻璃罩，浇水，弄挡风板等等，只是这朵玫瑰的爱，他没明白。</p>
<h3><a id="%E7%8B%90%E7%8B%B8%E8%AF%B7%E6%B1%82%E5%B0%8F%E7%8E%8B%E5%AD%90%E9%A9%AF%E6%9C%8D%E5%A5%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>狐狸请求小王子驯服她</h3>
<blockquote>
<p>“我的生活很单调。我猎杀鸡，人猎杀我。所有的鸡都是相同的，所有的人也是相同的。我已经有点厌倦。但如果你驯化我，我的生活将会充满阳光。我将能够辨别一种与众不同的脚步声。别人的脚步声会让我躲到地下。而你的脚步声就像音乐般美好，会让我走出洞穴。还有，你看。你看到那片麦田吗？我不吃面包。小麦对我来说没有用。麦田不会让我想起什么。这是很悲哀的！但你的头发是金色的。所以你来驯化我是很美好的事情！小麦也是金色的，到时它将会让我想起你。我喜欢风吹过麦穗的声音……”<br />
狐狸久久地凝望着小王子。<br />
“请你……请你驯化我！”他说。<br />
“没问题，”小王子回答说，“但我没有多少时间。我还有许多朋友要结识，还有许多事情要了解。”<br />
“你只能了解你驯化的东西，”狐狸说，“人类再也没有时间去了解什么东西了。他们无论需要什么都到商店里买现成的。但商店里不卖朋友，所以人类再也交不到朋友。如果你想找个朋友，请驯化我！”<br />
“我该怎么做呢？”小王子问。<br />
“你要非常有耐心，”狐狸说，“首先，你要在离我有点远的地方坐下，就像这样，坐在草地上。我会偷偷地看你，你不要说话。语言是误解的根源。但你每天都要坐得离我更近一点……”</p>
</blockquote>
<blockquote>
<p>第二天小王子回来了。<br />
“你每天最好在相同的时间来，”狐狸说，“比如说你定在下午四点来，那么到了三点我就会开始很高兴。时间越是接近，我就越高兴。等到四点，我会很焦躁，坐立不安；我已经发现了幸福的代价。但如果你每天在不同的时间来，我就不知道该在什么时候开始期待你的到来……我们需要仪式。”<br />
“仪式是什么？”小王子说。<br />
“这也是经常被遗忘的事情，”狐狸说，“它使得某个日子区别于其他日子，某个时刻不同于其他时刻。例如，那些猎人就有个仪式。每逢星期四，他们会和村里的女孩跳舞。所以星期四是个美好的日子！我可以到葡萄园里散步。但如果猎人并不在固定的日子跳舞，所有的日子都是相同的，那我就没有假期了。”</p>
</blockquote>
<p>小王子和狐狸这个邂逅，说实话有点难懂，我读了很多遍，特别是“驯服”这个词，让我很为难。正常你喜欢一个人，你不会对她说，你能不能来“驯服”我？要不人家肯定白眼你，心里想你是不是喜欢滴蜡烛的被虐变态。其实“驯服”二字，狐狸也做了解释，是叫做“创造关系”，说白了就是“交个朋友”。其实跟爱与被爱，还没啥关系。</p>
<p>那好，我们看下，狐狸这里给小王子自说自话提的请求，我总结起来无非两点：</p>
<ol>
<li>需要陪伴，不需要太多承诺</li>
<li>需要仪式感</li>
</ol>
<p>这两点，小王子做到了，狐狸就和他交了朋友。</p>
<p>但是，狐狸为什么想要小王子来驯服她呢？她说“你的头发是金色的。所以你来驯化我是很美好的事情！小麦也是金色的，到时它将会让我想起你。我喜欢风吹过麦穗的声音”。这个理由，小王子为啥能接受呢？</p>
<p>其实在遇到狐狸之前，小王子有遇到一园子的玫瑰。正常来说，我们人，不可能说找到一个一摸一样的人，就连找到99%近似的都很困难，但就玫瑰而言很简单，看到这一园子玫瑰，小王子很自然就想起了自己星球上的那朵玫瑰，所以他能明白狐狸的这个意思，也接受了驯服她的请求。</p>
<p>关于狐狸提的两点要求，其实是很直接的，而且很具有操作性。狐狸切切实实地告诉了小王子，自己想要什么，自己在想什么，小王子也不需要猜，他就懂了。狐狸需要陪伴，再者她喜欢有仪式感，如果给她的爱具有不确定性，她会焦躁，坐立不安。</p>
<p>狐狸其实是在教会小王子，怎么被爱。她给小王子提的要求，创造了她对小王子的依赖，也让小王子明白自己的需求，他如果也想要这段关系，他就会去做，而行动，胜过承诺。</p>
<p>到这里，小王子其实还没有学会什么是爱与被爱，他还仅仅只是懵懵懂懂地知道，自己绝对是被星球上的那朵玫瑰驯服了，他承认自己是迷上了她，但小王子还没明白，自己其实已经学会爱她。</p>
<h3><a id="%E5%B0%8F%E7%8E%8B%E5%AD%90%E4%B8%8E%E7%8B%90%E7%8B%B8%E5%91%8A%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小王子与狐狸告别</h3>
<blockquote>
<p>于是小王子驯化了狐狸。转眼他们就要彼此分别。<br />
“唉！”狐狸说，“……我会哭的。”<br />
“这要怪你，”小王子说，“我不希望你难过的，但你想要我驯化你……”<br />
“是这样的，”狐狸说。<br />
“那你还要哭！”小王子说。<br />
“是啊，”狐狸说。<br />
“所以你什么好处也没得到！”<br />
“我得到了好处，”狐狸说，“因为小麦的颜色。”<br />
然后他又说：<br />
“再去看看那些玫瑰吧。到时你会明白，你的玫瑰是独一无二的。然后回来跟我说再见，我会送给你一个秘密当礼物。”<br />
小王子又去看那些玫瑰。<br />
“你们根本不像我的玫瑰，你们现在什么也不是，”他说，“没有人驯化你们，你们也没有驯化任何人。你们就像先前那只狐狸。他原本只是普通的狐狸，和其他成千上万只狐狸没有什么不同。但我和他交了朋友，现在他是全世界独一无二的。”<br />
那些玫瑰听了很不舒服。<br />
“你们很美丽，但也很空虚，”他又说，“不会有人为你们去死。当然，寻常的路人会认为我的玫瑰花和你们差不多。但她比你们全部加起来还重要，因为我给她浇过水。因为我给她盖过玻璃罩。因为我为她挡过风。因为我为她消灭过毛毛虫（但留了两三条活口，好让它们变成蝴蝶）。因为我倾听过她的抱怨和吹嘘，甚至有时候也倾听她的沉默。因为她是我的玫瑰。”<br />
他回去找狐狸。<br />
“再见，”他说……<br />
“再见，”狐狸说，“这是我的秘密。它很简单：看东西只有用心才能看得清楚。重要的东西用眼睛是看不见的。”<br />
“重要的东西用眼睛是看不见的，”小王子跟着说，以便记住这句话。<br />
“正是你为你的玫瑰付出的时间，使得你的玫瑰是如此的重要。”<br />
“正是我为我的玫瑰付出的时间……”小王子跟着说，以便记住这句话。<br />
“人类已经忘记这条真理，”狐狸说，“但你千万不要忘记。你要永远为你驯化的东西负责。你要为你的玫瑰负责……”<br />
“我要为我的玫瑰负责……”小王子跟着说，以便记住这句话。</p>
</blockquote>
<p>小王子和狐狸告别之前，这位直男说“我不希望你难过的，但你想要我驯化你...”。这句话，其实放在当今社会上，有点儿像不负责任的渣男，但他不是，因为这一切是狐狸请求的，所以是不是那些又直又渣的男人背后，都有一个矛盾的女人？</p>
<p>至少狐狸不矛盾，她从一开始就目的明确，她喜欢风吹过麦穗的声音，而小王子赋予了麦田新的意义，她很感激。</p>
<p>她也明白，小王子其实还没有学会爱与被爱，所以她让小王子再去面对一次过往，也就是去一趟玫瑰花园。</p>
<p>这之后，小王子确实明白了他已经学会了怎么爱那朵玫瑰，他非常确定地说到，“寻常的路人会认为我的玫瑰花和你们差不多。但她比你们全部加起来还重要，因为我给她浇过水。因为我给她盖过玻璃罩。因为我为她挡过风。因为我为她消灭过毛毛虫（但留了两三条活口，好让它们变成蝴蝶）。因为我倾听过她的抱怨和吹嘘，甚至有时候也倾听她的沉默。因为她是我的玫瑰。”</p>
<p>然而他回来告别狐狸时，狐狸告诉他的两个道理和一个原则，我理解这两个道理，一个是为了教会小王子怎么被爱，一个是为了教会他辨识爱。最后的一个原则，是为了教会小王子要如何幸福。</p>
<p>“重要的东西用眼睛是看不见的”，你只看到了骄傲的玫瑰在释放花香，却看不到她是为了你释放了自己最好的一面，眼睛看不见，因为要将心比心。</p>
<p>“正是你为你的玫瑰付出的时间，使得你的玫瑰是如此的重要”。如果没有共同的记忆，没有付出时间，快餐式的甜言蜜语和冲动之下性关系，都不会是爱，这些都只是当下的刺激，都不重要。</p>
<p>“你要永远为你驯化的东西负责。你要为你的玫瑰负责”，如果爱一人，就要负责到底，这是狐狸的忠告，也是幸福的必要条件。朝三暮四，其实对谁都不会快乐。</p>
<h3><a id="%E5%B0%8F%E7%8E%8B%E5%AD%90%E7%9A%84%E5%8F%8D%E6%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>小王子的反思</h3>
<p>后来，小王子有过一段反思，经过了这段时间，我们可以看出他确实知道了怎么爱那朵玫瑰，怎么接受玫瑰的爱，他想要回到他的星球，继续这段关系。</p>
<blockquote>
<p>“我不该把她的话当真，”有一天他告诉我，“你千万不能把花儿的话当真。我们只要凝望她们的模样，闻闻她们的芳香就好。我的花朵让整个星球弥漫着香味，但我却不懂得为此而高兴。那几句关于虎爪的胡话让我很生气，但她其实是在撒娇，希望我能怜惜她……”<br />
他继续说着他的心里话：<br />
“可惜从前我什么都不懂！我应该看她的行动，而不是听她的言语！她为我散发芬芳，点亮我的生活。我不应该离开她的，我应该看出藏在她那些小把戏后面的柔情。花儿的心事好难捉摸的！当时我太小了，不懂得爱是什么。”</p>
</blockquote>
<p>最后，小王子的结局是，他放弃了自己的躯体，让自己的灵魂回到了那颗星球，回到了玫瑰身边。</p>
<h3><a id="%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>我的思考</h3>
<p>《小王子》这本书，告诉我：</p>
<ol>
<li>爱一个人，要行动起来</li>
<li>想要被爱，要让对方知道自己的需求，让对方能有所行动</li>
<li>辨识爱，一，是由于对这个人投入了时间，所以她成了独一无二的一份爱</li>
<li>辨识爱，二，要用心去看，将心比心地去感受，眼睛是看不出来的。</li>
<li>负责，如果想要爱与被爱，就要负责到底。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shell备忘录]]></title>
    <link href="chaoranlaoge.top/16272759911547.html"/>
    <updated>2021-07-26T13:06:31+08:00</updated>
    <id>chaoranlaoge.top/16272759911547.html</id>
    <content type="html"><![CDATA[
<h2><a id="vim%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%87%E5%BF%98%E5%BD%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>vim 快捷键备忘录</h2>
<p>G 到文件尾部<br />
:num num指的是行号<br />
:vs file_path 左右打开文件<br />
:sp file_path 上下打开文件<br />
:winc j/k/h/l 上下左右窗口光标移动</p>
<h2><a id="%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文件处理类型</h2>
<ul>
<li>
<p>查看文件夹目录底下的所有文件大小<br />
<code> du -h --max-depth=1</code></p>
</li>
<li>
<p>查看文件系统大小列表<br />
<code> df -h</code></p>
</li>
<li>
<p>grep去掉grep自身的进程并获取进程号<br />
<code> ps -eo pid,cmd | grep exec | grep -v grep | awk 'print {$1}'</code></p>
</li>
<li>
<p>ps 获取进程开始时间<br />
<code> ps -eo lstart,etime | grep exec</code></p>
</li>
<li>
<p>字符串截取 截取字符串中左边或者右边的字符串</p>
</li>
</ul>
<pre><code class="language-shell">name=filebeat/platform
echo ${name%/*} # = filebeat = 删除了字符 '/' 右边的所有字符
echo ${name##*/} # = platform = 删除了字符 '/' 左边的所有字符
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记观影《唐人街探案3》的十个优秀细节]]></title>
    <link href="chaoranlaoge.top/16132317373263.html"/>
    <updated>2021-02-13T23:55:37+08:00</updated>
    <id>chaoranlaoge.top/16132317373263.html</id>
    <content type="html"><![CDATA[
<ol>
<li>同声传译的耳机</li>
<li>串联秦风的儿时回忆作为细节补充</li>
<li>日本cosplay文化和游行</li>
<li>日本庙会游街文化和盂兰盆节</li>
<li>日本相扑和剑道</li>
<li>3个穷人2个面包公平分配问题</li>
<li>Q的揭示</li>
<li>各种街景设计，新干线展示，特殊地点，比如秋叶原，特色弹珠厅</li>
<li>日本黑道文化+纹身文化+泡汤文化</li>
<li>Q的五个测试设计和接头人</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[走投无路，我只好卖身]]></title>
    <link href="chaoranlaoge.top/16127114053987.html"/>
    <updated>2021-02-07T23:23:25+08:00</updated>
    <id>chaoranlaoge.top/16127114053987.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16127114053987/16127117730903.jpg" alt="" /></p>
<p>关于奇葩说第七季第14期的辩题：</p>
<p>“奇葩星球新科技，人们可以自由买卖生命时间，你支持吗？”</p>
<p>本文是，我看完之后正反方辩论之后，对于这个科技如何实现的一种想象。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现形式</h2>
<p>我觉得，买卖生命这个交易，如果要服务好交易双方，至少需要满足以下几个条件：</p>
<ul>
<li>买卖双方寿命可预测，否则没人敢冒险卖</li>
<li>买方接收到寿命时，如果濒临死亡，也要能起死回生，不然买了也没用</li>
<li>寿命叠加后，人体状态要能恢复，如果人衰老到无法动弹，要能够返老还童</li>
<li>7日内可撤回交易，也就是假如买方作为受益方已经受益，但卖方提出交易撤回，需要能使买方回到过去的状态，比如返老还童或者起死回生了都要回到交易前状态，意味着人要能回到过去</li>
<li>交易完成之后，卖方自愿承担后果，买方可自由再交易</li>
</ul>
<p>思考完以上几个条件后，我在思考，近一两百年或许人类可能永远无法攻克，如何使一个人回到过去，也无法预测一个人的寿命，也可能无法攻克如何使一个人返老还童，也可能无法攻克使一个濒危死亡的人起死回生，我们短期内根本无法尝到这个科技的甜头。但是，未来的近一两百年，量子数据库出现是有可能的，每一个人类的记忆以及知识图谱，实现数字化的上传和下载都也是可能的，从而可以实现人类大脑的重置，可以实现“借体还魂”，实现另一种形式的重生和生命时间的交易。</p>
<p>因此，买卖生命这个交易，或许可以转换成，出售身体自主权为交易内容。也就是如题所说的”卖身“，这样可以无需要求寿命可预期，卖方只要出售身体自主权，即便中途死亡，也是买方承担风险。具体的交易形式如下：</p>
<ol>
<li>买方生前，从自己的遗产管理协议中签订，订阅哪一个意识体托管服务商，多少次”借体还魂“的服务，买方要提出自己的活动要求供卖方考量</li>
<li>服务商会在买方死亡24小时内，数字化的上传买方的所有记忆以及知识图谱</li>
<li>卖方根据每一个服务商的每小时的采购价格，出售自己至少7日之后的哪一个时间段内的身体自主权，签订协议，服务商会告知卖方需要承担买方掌握其身体自主权后可能产生的生命风险</li>
<li>卖方提前收到交易款，7日内可退款，撤销交易</li>
<li>买方可以指定卖方的性别，年龄，身体状况作为交易要求，从而实现返老还童的要求</li>
<li>卖方可以要求买方的性别，活动的形式/范围。</li>
<li>假如卖方在交易过程中身体遭受意外，买方需要承担意外死亡/伤害的风险，而且需要承担所有医疗费用，以及保险费用。</li>
<li>交换身体自主权的当天，卖方大脑的记忆和知识图谱会全部上传暂存服务器，同时买方的知识图谱和部分记忆片段会下载到卖方大脑，服务商需要随时监视买方活动，避免所有伤害卖方身体的可能，并具备随时暂停交易，保证卖方的权利</li>
<li>法律应当规定伦理道德底线，交易双方必须是出生时间至少相差50年的人，而且素未谋面。交易过程中，买方只能够获取部分与身份无关的记忆片段，但拥有生前的知识，如果交易过程中买方回忆起自身身份，交易停止。</li>
</ol>
<p>那么如果交易真的要成立，服务商是中间不可或缺的环境，并且服务商所依赖的”量子数据库“，更是其核心技术，而这个核心技术如何实现呢？</p>
<h2><a id="%E8%84%91%E6%B4%9E%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脑洞核心技术</h2>
<p>（下面就是一派胡言）</p>
<p>纵观现今，2021年，所有数据存储都依赖存储介质，未来肯定也是，存储介质实现加量不加价，甚至白菜价都是未来的趋势。真正的问题在于，现有的数据库系统都需要人的设计数据形式，不管是图/表/还是图谱，都需要人为先设计存储形式再存储数据，才能以我们需要的形式进行读取。而这些人为设计的元数据信息，都是有限集合。如何设计一个无限的元数据集合，做到自动直接地进行数据存储，并实现按需读取，才是未来的关键。</p>
<p>我们知道，任何生命在当下的三维世界里的所有行动都会产生不确定性，而不确定性本身没办法记录，但不确定性本身又何尝不能作为存储信息的单元呢？从古至今，每一个不确定性只要都能被打上了标签，那么这个标签形成的链，将能够存储极大的信息量，而这个链，便能成为一种“量子数据库”。不确定性永远都能被自动地产生，所以这个数据库存储量是无穷无尽的。数据库的形成里，我们不记录不确定性，我们只捕获这个不确定性，并关联确定性事件。举个最简单的例子，薛定谔的猫在盒子里，我们只把猫的生死，这个叠加态关联上一个确定性的标签A。数据库的写入时，当我们往标签A写入一条数据时，这条数据会绑定到叠加态坍缩后的可观测态，于此同时我们记录可观测态和数据的关联，实现直接地数据存储。数据读取时，我们从存储介质检索标签A，以及观测态来获取数据。根据这个简单原理，理论上标签的无穷尽的，而每个标签能否再次写入数据是能够被判定的，因为观测态如果重复了就拒绝，如果不重复就可以写入，而且每个数据都可以被检索，从而可以实现这个量子数据库。不仅如此，这个理论上无穷尽的数据库，是足以存下现在所有存活人类的记忆以及知识图谱的，但一切都建立在付费的基础上，毕竟存储介质都是有价值的物理实体。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Centos7 Hadoop集群安装]]></title>
    <link href="chaoranlaoge.top/16127105620051.html"/>
    <updated>2021-02-07T23:09:22+08:00</updated>
    <id>chaoranlaoge.top/16127105620051.html</id>
    <content type="html"><![CDATA[
<p>阿里云上申请三台每小时0.5块钱的机器，一小时总花费1.5块钱。<br />
根据以下教程，在20分钟之内，搞定整个Hadoop单Master集群部署。</p>
<span id="more"></span><!-- more -->
<p>先在阿里云上申请3台最便宜的服务器，在同一个区就行，然后就直接开搞</p>
<h2><a id="%E8%AE%BE%E7%BD%AEhosts%E5%92%8Cssh" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>设置hosts和ssh</h2>
<pre><code class="language-shell">vim /etc/hosts

# 添加内网IP以及相应的hostname，比如：
172.31.140.249 node03
172.31.140.244 node01
172.31.140.246 node02
# :wq保存退出

# 如果没有设置对hostname, 如下设置命令
hostnamectl set-hostname node01
</code></pre>
<ul>
<li>安装依赖</li>
</ul>
<pre><code class="language-shell">yum install ssh, pdsh
</code></pre>
<ul>
<li>三台机器设置免密</li>
</ul>
<pre><code class="language-shell"># 举个例子，将node02到node01的登陆免密
[root@node02 ~]: ssh-keygen # 三次回车，不设置额外明文密码，生成自己机器的pub公共密钥文件，id_rsa.pub
[root@node02 ~]: scp ~/.ssh/id_rsa.pub node01:~/.ssh/node02.pub  # 配置自己登陆自己的公钥
# 登陆node01
[root@node01 ~]: cat ~/.ssh/node02.pub &gt;&gt; ~/.ssh/authorized_keys # 追加免认证密钥
# 登陆node02
[root@node02 ~]: ssh node01 #此时就免认证

# 然后这里有没有什么更快捷的方法能相互认证免密？
</code></pre>
<h2><a id="%E5%AE%89%E8%A3%85jdk" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装JDK</h2>
<p>从Oracle官网（需要登陆账号，没有的需要先注册再下载）下载安装压缩包，上传到一台阿里云服务器，其他的用内网传输</p>
<ul>
<li>创建安装目录</li>
</ul>
<pre><code class="language-shell">mkdir /usr/local/java/
</code></pre>
<ul>
<li>解压至安装目录</li>
</ul>
<pre><code class="language-shell">tar -zxvf jdk-8u281-linux-x64.tar.gz -C /usr/local/java/
</code></pre>
<ul>
<li>设置环境变量</li>
</ul>
<pre><code class="language-shell"># 修改配置文件
vim /etc/profile
# 输入 G, o, 进入insert模式，然后粘贴以下内容
export JAVA_HOME=/usr/local/java/jdk1.8.0_281
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
# esc 输入:wq 退出vim
source /etc/profile # 使环境变量生效
ln -s /usr/local/java/jdk1.8.0_171/bin/java /usr/bin/java # 添加软链接
java -version # 验证

</code></pre>
<h2><a id="%E5%AE%89%E8%A3%85hadoop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>安装Hadoop</h2>
<ul>
<li>下载Hadoop</li>
</ul>
<pre><code class="language-shell">wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.2/hadoop-3.2.2.tar.gz
</code></pre>
<ul>
<li>解压到文件夹并重命名</li>
</ul>
<pre><code class="language-shell">tar -xzvf hadoop-3.2.2.tar.gz -C /usr/local
mv /usr/local/hadoop-3.2.2 /usr/local/hadoop
</code></pre>
<h2><a id="%E4%BF%AE%E6%94%B9hadoop%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改hadoop配置</h2>
<ul>
<li>core-site.xml</li>
</ul>
<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;
        &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt;
        &lt;description&gt;Abase for other temporary directories.&lt;/description&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;fs.defaultFS&lt;/name&gt;
        &lt;value&gt;hdfs://node01:9000&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<blockquote>
<p><strong>特别注意：如没有配置<code>hadoop.tmp.dir</code>参数，此时系统默认的临时目录为：<code>/tmp/hadoo-hadoop</code>。而这个目录在每次重启后都会被删除，必须重新执行format才行，否则会出错。</strong></p>
<p>摘自博客 - 纯洁的微笑 - hadoop分布式集群搭建</p>
</blockquote>
<ul>
<li>hdfs-site.xml</li>
</ul>
<pre><code class="language-xml">&lt;configuration&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.replication&lt;/name&gt;
        &lt;value&gt;3&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.name.dir&lt;/name&gt;
        &lt;value&gt;/usr/local/hadoop/hdfs/name&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;dfs.data.dir&lt;/name&gt;
        &lt;value&gt;/usr/local/hadoop/hdfs/data&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>mapred-site.xml</li>
</ul>
<pre><code class="language-xml">&lt;configuration&gt;
  &lt;property&gt;
      &lt;name&gt;mapreduce.framework.name&lt;/name&gt;
      &lt;value&gt;yarn&lt;/value&gt;
  &lt;/property&gt;
   &lt;property&gt;
      &lt;name&gt;mapred.job.tracker&lt;/name&gt;
      &lt;value&gt;http://hadoop-master:9001&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>yarn-site.xml</li>
</ul>
<pre><code class="language-xml">&lt;configuration&gt;
&lt;!-- Site specific YARN configuration properties --&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;
        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;
    &lt;/property&gt;
    &lt;property&gt;
        &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;
        &lt;value&gt;hadoop-master&lt;/value&gt;
    &lt;/property&gt;
&lt;/configuration&gt;
</code></pre>
<ul>
<li>修改执行用户</li>
</ul>
<p>在start-dfs.sh和stop-dfs.sh中开头空白处添加：</p>
<pre><code class="language-shell">HDFS_DATANODE_USER=root
HADOOP_SECURE_DN_USER=hdfs
HDFS_NAMENODE_USER=root
HDFS_SECONDARYNAMENODE_USER=root 
</code></pre>
<p>在start-yarn.sh和stop-yarn.sh开头空白处添加：</p>
<pre><code class="language-shell">YARN_RESOURCEMANAGER_USER=root
HADOOP_SECURE_DN_USER=yarn
YARN_NODEMANAGER_USER=root
</code></pre>
<ul>
<li>配置JAVA_HOME到hadoop-env.sh和yarn-env.sh</li>
</ul>
<pre><code class="language-shell"># 输入 G, o, 进入insert模式，然后粘贴以下内容
export JAVA_HOME=/usr/local/java/jdk1.8.0_281
</code></pre>
<ul>
<li>同步hadoop文件夹到其他slave服务器</li>
</ul>
<pre><code class="language-shell">scp -r /usr/local/hadoop node02:/usr/local/
scp -r /usr/local/hadoop node03:/usr/local/
</code></pre>
<ul>
<li>workers文件</li>
</ul>
<pre><code class="language-shell">vi /usr/local/hadoop/etc/hadoop/slaves
## 内容
node02
node03
</code></pre>
<ul>
<li>配置环境变量</li>
</ul>
<pre><code class="language-shell"># 修改配置文件
vim /etc/profile
# 输入 G, o, 进入insert模式，然后粘贴以下内容
export HADOOP_HOME=/usr/local/hadoop
export PATH=$PATH:$HADOOP_HOME/bin 
# esc 输入:wq 退出vim
source /etc/profile # 使环境变量生效
</code></pre>
<h2><a id="%E5%90%AF%E5%8A%A8hadoop" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>启动Hadoop</h2>
<pre><code class="language-shell">cd $HADOOP_HOME
# 首次启动才需要
bin/hadoop namenode -format 

# 启动集群
sbin/start-all.sh

# 关闭集群
sbin/stop-all.sh
</code></pre>

]]></content>
  </entry>
  
</feed>
